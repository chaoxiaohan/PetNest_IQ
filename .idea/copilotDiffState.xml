<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.petnestiq&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.petnestiq&quot;&#10;        minSdk = 26  // 提高到API 26以获得更好的Material You支持&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;3.1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.5&quot;)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.4&quot;)&#10;    // 添加动态颜色支持（获取色）&#10;    implementation(&quot;androidx.compose.material3:material3-window-size-class:1.1.2&quot;)&#10;&#10;    // 添加Coil库用于图片加载&#10;    implementation(&quot;io.coil-kt:coil-compose:2.5.0&quot;)&#10;&#10;    // 添加Gson用于JSON序列化&#10;    implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)&#10;&#10;    // 添加MQTT客户端&#10;    implementation(&quot;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.5&quot;)&#10;    implementation(&quot;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&quot;)&#10;&#10;    // 添加网络请求库用于AI聊天&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // 添加ExoPlayer用于视频流播放&#10;    implementation(&quot;androidx.media3:media3-exoplayer:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-ui:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-common:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-exoplayer-hls:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-exoplayer-rtsp:1.2.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.petnestiq&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.petnestiq&quot;&#10;        minSdk = 26  // 提高到API 26以获得更好的Material You支持&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;3.1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(&quot;androidx.navigation:navigation-compose:2.7.5&quot;)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.4&quot;)&#10;    // 添加动态颜色支持（获取色）&#10;    implementation(&quot;androidx.compose.material3:material3-window-size-class:1.1.2&quot;)&#10;&#10;    // 添加Coil库用于图片加载&#10;    implementation(&quot;io.coil-kt:coil-compose:2.5.0&quot;)&#10;&#10;    // 添加Gson用于JSON序列化&#10;    implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)&#10;&#10;    // 添加MQTT客户端&#10;    implementation(&quot;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.5&quot;)&#10;    implementation(&quot;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&quot;)&#10;&#10;    // 添加网络请求库用于AI聊天&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // 添加ExoPlayer用于视频流播放&#10;    implementation(&quot;androidx.media3:media3-exoplayer:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-ui:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-common:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-exoplayer-hls:1.2.0&quot;)&#10;    implementation(&quot;androidx.media3:media3-exoplayer-rtsp:1.2.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/ChatData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/ChatData.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import java.util.UUID&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * 聊天消息数据类&#10; */&#10;data class ChatMessage(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val content: String,&#10;    val isFromUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val isTyping: Boolean = false&#10;) {&#10;    fun getFormattedTime(): String {&#10;        val sdf = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;        return sdf.format(Date(timestamp))&#10;    }&#10;}&#10;&#10;/**&#10; * DeepSeek API 请求数据模型&#10; */&#10;data class DeepSeekRequest(&#10;    val model: String = &quot;deepseek-chat&quot;,&#10;    val messages: List&lt;ApiMessage&gt;,&#10;    val temperature: Double = 0.7,&#10;    val max_tokens: Int = 1000,&#10;    val stream: Boolean = false&#10;)&#10;&#10;data class ApiMessage(&#10;    val role: String, // &quot;user&quot; 或 &quot;assistant&quot; 或 &quot;system&quot;&#10;    val content: String&#10;)&#10;&#10;/**&#10; * DeepSeek API 响应数据模型&#10; */&#10;data class DeepSeekResponse(&#10;    val id: String,&#10;    val objectType: String,&#10;    val created: Long,&#10;    val model: String,&#10;    val choices: List&lt;Choice&gt;,&#10;    val usage: Usage&#10;)&#10;&#10;data class Choice(&#10;    val index: Int,&#10;    val message: ApiMessage,&#10;    val finish_reason: String&#10;)&#10;&#10;data class Usage(&#10;    val prompt_tokens: Int,&#10;    val completion_tokens: Int,&#10;    val total_tokens: Int&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#10;&#10;import java.util.UUID&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * 聊天消息数据类&#10; */&#10;data class ChatMessage(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val content: String,&#10;    val isFromUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val isTyping: Boolean = false,&#10;    val isStreaming: Boolean = false&#10;) {&#10;    fun getFormattedTime(): String {&#10;        val sdf = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;        return sdf.format(Date(timestamp))&#10;    }&#10;}&#10;&#10;/**&#10; * DeepSeek API 请求数据模型&#10; */&#10;data class DeepSeekRequest(&#10;    val model: String = &quot;deepseek-chat&quot;,&#10;    val messages: List&lt;ApiMessage&gt;,&#10;    val temperature: Double = 0.7,&#10;    val max_tokens: Int = 1000,&#10;    val stream: Boolean = false&#10;)&#10;&#10;data class ApiMessage(&#10;    val role: String, // &quot;user&quot; 或 &quot;assistant&quot; 或 &quot;system&quot;&#10;    val content: String&#10;)&#10;&#10;/**&#10; * DeepSeek API 响应数据模型&#10; */&#10;data class DeepSeekResponse(&#10;    val id: String,&#10;    val objectType: String,&#10;    val created: Long,&#10;    val model: String,&#10;    val choices: List&lt;Choice&gt;,&#10;    val usage: Usage&#10;)&#10;&#10;data class Choice(&#10;    val index: Int,&#10;    val message: ApiMessage,&#10;    val finish_reason: String&#10;)&#10;&#10;data class Usage(&#10;    val prompt_tokens: Int,&#10;    val completion_tokens: Int,&#10;    val total_tokens: Int&#10;)&#10;&#10;/**&#10; * 流式响应数据模型&#10; */&#10;data class StreamChoice(&#10;    val index: Int,&#10;    val delta: StreamDelta,&#10;    val finish_reason: String?&#10;)&#10;&#10;data class StreamDelta(&#10;    val content: String?&#10;)&#10;&#10;data class StreamResponse(&#10;    val id: String,&#10;    val objectType: String,&#10;    val created: Long,&#10;    val model: String,&#10;    val choices: List&lt;StreamChoice&gt;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/DeviceConfigManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/DeviceConfigManager.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;data class MqttConfig(&#10;    val serverUrl: String = &quot;mqtt://localhost&quot;,&#10;    val port: Int = 1883,&#10;    val clientId: String = &quot;PetNestIQ_Client&quot;,&#10;    val username: String = &quot;&quot;,&#10;    val password: String = &quot;&quot;,&#10;    val subscribeTopic: String = &quot;/device/data&quot;,&#10;    val publishTopic: String = &quot;/device/control&quot;,&#10;    val useSSL: Boolean = false,&#10;    val autoReconnect: Boolean = true&#10;)&#10;&#10;data class BluetoothConfig(&#10;    val deviceName: String = &quot;PetNest Device&quot;,&#10;    val macAddress: String = &quot;&quot;,&#10;    val autoConnect: Boolean = false,&#10;    val connectionTimeout: Int = 30&#10;)&#10;&#10;data class DeviceConfig(&#10;    val name: String,&#10;    val mqttConfig: MqttConfig,&#10;    val bluetoothConfig: BluetoothConfig,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;class DeviceConfigManager private constructor(private val context: Context) {&#10;    private val preferences: SharedPreferences = context.getSharedPreferences(&#10;        &quot;device_config_prefs&quot;, Context.MODE_PRIVATE&#10;    )&#10;&#10;    private val gson = Gson()&#10;&#10;    // MQTT配置状态&#10;    private val _mqttConfig = MutableStateFlow(loadMqttConfig())&#10;    val mqttConfig: StateFlow&lt;MqttConfig&gt; = _mqttConfig.asStateFlow()&#10;&#10;    // 蓝牙配置状态&#10;    private val _bluetoothConfig = MutableStateFlow(loadBluetoothConfig())&#10;    val bluetoothConfig: StateFlow&lt;BluetoothConfig&gt; = _bluetoothConfig.asStateFlow()&#10;&#10;    // 已保存的配置列表&#10;    private val _configList = MutableStateFlow(loadConfigList())&#10;    val configList: StateFlow&lt;List&lt;String&gt;&gt; = _configList.asStateFlow()&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DeviceConfigManager? = null&#10;&#10;        fun getInstance(context: Context): DeviceConfigManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DeviceConfigManager(context.applicationContext).also { INSTANCE = it }&#10;            }&#10;        }&#10;&#10;        private const val KEY_MQTT_CONFIG = &quot;mqtt_config&quot;&#10;        private const val KEY_BLUETOOTH_CONFIG = &quot;bluetooth_config&quot;&#10;        private const val KEY_CONFIG_LIST = &quot;config_list&quot;&#10;        private const val KEY_CONFIG_PREFIX = &quot;saved_config_&quot;&#10;    }&#10;&#10;    // 加载MQTT配置&#10;    private fun loadMqttConfig(): MqttConfig {&#10;        val configJson = preferences.getString(KEY_MQTT_CONFIG, null)&#10;        return if (configJson != null) {&#10;            try {&#10;                gson.fromJson(configJson, MqttConfig::class.java) ?: MqttConfig()&#10;            } catch (e: Exception) {&#10;                MqttConfig() // 返回默认配置&#10;            }&#10;        } else {&#10;            MqttConfig() // 返回默认配置&#10;        }&#10;    }&#10;&#10;    // 加载蓝牙配置&#10;    private fun loadBluetoothConfig(): BluetoothConfig {&#10;        val configJson = preferences.getString(KEY_BLUETOOTH_CONFIG, null)&#10;        return if (configJson != null) {&#10;            try {&#10;                gson.fromJson(configJson, BluetoothConfig::class.java) ?: BluetoothConfig()&#10;            } catch (e: Exception) {&#10;                BluetoothConfig() // 返回默认配置&#10;            }&#10;        } else {&#10;            BluetoothConfig() // 返回默认配置&#10;        }&#10;    }&#10;&#10;    // 加载配置列表&#10;    private fun loadConfigList(): List&lt;String&gt; {&#10;        val configListJson = preferences.getString(KEY_CONFIG_LIST, null)&#10;        return if (configListJson != null) {&#10;            try {&#10;                val type = object : TypeToken&lt;List&lt;String&gt;&gt;() {}.type&#10;                gson.fromJson(configListJson, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                emptyList()&#10;            }&#10;        } else {&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // 更新MQTT配置&#10;    fun updateMqttConfig(config: MqttConfig) {&#10;        _mqttConfig.value = config&#10;        saveMqttConfig(config)&#10;    }&#10;&#10;    // 更新蓝牙配置&#10;    fun updateBluetoothConfig(config: BluetoothConfig) {&#10;        _bluetoothConfig.value = config&#10;        saveBluetoothConfig(config)&#10;    }&#10;&#10;    // 保存MQTT配置&#10;    private fun saveMqttConfig(config: MqttConfig) {&#10;        val configJson = gson.toJson(config)&#10;        preferences.edit()&#10;            .putString(KEY_MQTT_CONFIG, configJson)&#10;            .apply()&#10;    }&#10;&#10;    // 保存蓝牙配置&#10;    private fun saveBluetoothConfig(config: BluetoothConfig) {&#10;        val configJson = gson.toJson(config)&#10;        preferences.edit()&#10;            .putString(KEY_BLUETOOTH_CONFIG, configJson)&#10;            .apply()&#10;    }&#10;&#10;    // 保存完整配置组合&#10;    fun saveConfig(name: String) {&#10;        val deviceConfig = DeviceConfig(&#10;            name = name,&#10;            mqttConfig = _mqttConfig.value,&#10;            bluetoothConfig = _bluetoothConfig.value&#10;        )&#10;&#10;        // 保存配置到SharedPreferences&#10;        val configJson = gson.toJson(deviceConfig)&#10;        preferences.edit()&#10;            .putString(KEY_CONFIG_PREFIX + name, configJson)&#10;            .apply()&#10;&#10;        // 更新配置列表&#10;        val currentList = _configList.value.toMutableList()&#10;        if (!currentList.contains(name)) {&#10;            currentList.add(name)&#10;            _configList.value = currentList&#10;            saveConfigList(currentList)&#10;        }&#10;    }&#10;&#10;    // 加载完整配置组合&#10;    fun loadConfig(name: String) {&#10;        val configJson = preferences.getString(KEY_CONFIG_PREFIX + name, null)&#10;        if (configJson != null) {&#10;            try {&#10;                val deviceConfig = gson.fromJson(configJson, DeviceConfig::class.java)&#10;                if (deviceConfig != null) {&#10;                    updateMqttConfig(deviceConfig.mqttConfig)&#10;                    updateBluetoothConfig(deviceConfig.bluetoothConfig)&#10;                }&#10;            } catch (e: Exception) {&#10;                // 加载失败，保持当前配置&#10;            }&#10;        }&#10;    }&#10;&#10;    // 删除保存的配置&#10;    fun deleteConfig(name: String) {&#10;        preferences.edit()&#10;            .remove(KEY_CONFIG_PREFIX + name)&#10;            .apply()&#10;&#10;        val currentList = _configList.value.toMutableList()&#10;        currentList.remove(name)&#10;        _configList.value = currentList&#10;        saveConfigList(currentList)&#10;    }&#10;&#10;    // 保存配置列表&#10;    private fun saveConfigList(list: List&lt;String&gt;) {&#10;        val listJson = gson.toJson(list)&#10;        preferences.edit()&#10;            .putString(KEY_CONFIG_LIST, listJson)&#10;            .apply()&#10;    }&#10;&#10;    // 获取当前MQTT配置（用于其他组件访问）&#10;    fun getCurrentMqttConfig(): MqttConfig = _mqttConfig.value&#10;&#10;    // 获取当前蓝牙配置（用于其他组件访问）&#10;    fun getCurrentBluetoothConfig(): BluetoothConfig = _bluetoothConfig.value&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.content.SharedPreferences&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import com.google.gson.Gson&#13;&#10;import com.google.gson.reflect.TypeToken&#13;&#10;&#13;&#10;data class MqttConfig(&#13;&#10;    val serverUrl: String = &quot;ssl://e35491cb0c.st1.iotda-device.cn-north-4.myhuaweicloud.com&quot;,&#13;&#10;    val port: Int = 8883,&#13;&#10;    val clientId: String = &quot;688879e2d582f20018403921_text1_0_0_2025072907&quot;,&#13;&#10;    val username: String = &quot;688879e2d582f20018403921_text1&quot;,&#13;&#10;    val password: String = &quot;bdd6a2f87eab3e9dd81325957547fa3b5b566f1abfbdb9850249b3b4984f277e&quot;,&#13;&#10;    val subscribeTopic: String = &quot;/device/data&quot;,&#13;&#10;    val publishTopic: String = &quot;/device/control&quot;,&#13;&#10;    val useSSL: Boolean = true,&#13;&#10;    val autoReconnect: Boolean = true&#13;&#10;)&#13;&#10;&#13;&#10;data class BluetoothConfig(&#13;&#10;    val deviceName: String = &quot;PetNest Device&quot;,&#13;&#10;    val macAddress: String = &quot;&quot;,&#13;&#10;    val autoConnect: Boolean = false,&#13;&#10;    val connectionTimeout: Int = 30&#13;&#10;)&#13;&#10;&#13;&#10;data class DeviceConfig(&#13;&#10;    val name: String,&#13;&#10;    val mqttConfig: MqttConfig,&#13;&#10;    val bluetoothConfig: BluetoothConfig,&#13;&#10;    val timestamp: Long = System.currentTimeMillis()&#13;&#10;)&#13;&#10;&#13;&#10;class DeviceConfigManager private constructor(private val context: Context) {&#13;&#10;    private val preferences: SharedPreferences = context.getSharedPreferences(&#13;&#10;        &quot;device_config_prefs&quot;, Context.MODE_PRIVATE&#13;&#10;    )&#13;&#10;&#13;&#10;    private val gson = Gson()&#13;&#10;&#13;&#10;    // MQTT配置状态&#13;&#10;    private val _mqttConfig = MutableStateFlow(loadMqttConfig())&#13;&#10;    val mqttConfig: StateFlow&lt;MqttConfig&gt; = _mqttConfig.asStateFlow()&#13;&#10;&#13;&#10;    // 蓝牙配置状态&#13;&#10;    private val _bluetoothConfig = MutableStateFlow(loadBluetoothConfig())&#13;&#10;    val bluetoothConfig: StateFlow&lt;BluetoothConfig&gt; = _bluetoothConfig.asStateFlow()&#13;&#10;&#13;&#10;    // 已保存的配置列表&#13;&#10;    private val _configList = MutableStateFlow(loadConfigList())&#13;&#10;    val configList: StateFlow&lt;List&lt;String&gt;&gt; = _configList.asStateFlow()&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        @Volatile&#13;&#10;        private var INSTANCE: DeviceConfigManager? = null&#13;&#10;&#13;&#10;        fun getInstance(context: Context): DeviceConfigManager {&#13;&#10;            return INSTANCE ?: synchronized(this) {&#13;&#10;                INSTANCE ?: DeviceConfigManager(context.applicationContext).also { INSTANCE = it }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private const val KEY_MQTT_CONFIG = &quot;mqtt_config&quot;&#13;&#10;        private const val KEY_BLUETOOTH_CONFIG = &quot;bluetooth_config&quot;&#13;&#10;        private const val KEY_CONFIG_LIST = &quot;config_list&quot;&#13;&#10;        private const val KEY_CONFIG_PREFIX = &quot;saved_config_&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载MQTT配置&#13;&#10;    private fun loadMqttConfig(): MqttConfig {&#13;&#10;        val configJson = preferences.getString(KEY_MQTT_CONFIG, null)&#13;&#10;        return if (configJson != null) {&#13;&#10;            try {&#13;&#10;                gson.fromJson(configJson, MqttConfig::class.java) ?: MqttConfig()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                MqttConfig() // 返回默认配置&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            MqttConfig() // 返回默认配置&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载蓝牙配置&#13;&#10;    private fun loadBluetoothConfig(): BluetoothConfig {&#13;&#10;        val configJson = preferences.getString(KEY_BLUETOOTH_CONFIG, null)&#13;&#10;        return if (configJson != null) {&#13;&#10;            try {&#13;&#10;                gson.fromJson(configJson, BluetoothConfig::class.java) ?: BluetoothConfig()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                BluetoothConfig() // 返回默认配置&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            BluetoothConfig() // 返回默认配置&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载配置列表&#13;&#10;    private fun loadConfigList(): List&lt;String&gt; {&#13;&#10;        val configListJson = preferences.getString(KEY_CONFIG_LIST, null)&#13;&#10;        return if (configListJson != null) {&#13;&#10;            try {&#13;&#10;                val type = object : TypeToken&lt;List&lt;String&gt;&gt;() {}.type&#13;&#10;                gson.fromJson(configListJson, type) ?: emptyList()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                emptyList()&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            emptyList()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 更新MQTT配置&#13;&#10;    fun updateMqttConfig(config: MqttConfig) {&#13;&#10;        _mqttConfig.value = config&#13;&#10;        saveMqttConfig(config)&#13;&#10;    }&#13;&#10;&#13;&#10;    // 更新蓝牙配置&#13;&#10;    fun updateBluetoothConfig(config: BluetoothConfig) {&#13;&#10;        _bluetoothConfig.value = config&#13;&#10;        saveBluetoothConfig(config)&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存MQTT配置&#13;&#10;    private fun saveMqttConfig(config: MqttConfig) {&#13;&#10;        val configJson = gson.toJson(config)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_MQTT_CONFIG, configJson)&#13;&#10;            .apply()&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存蓝牙配置&#13;&#10;    private fun saveBluetoothConfig(config: BluetoothConfig) {&#13;&#10;        val configJson = gson.toJson(config)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_BLUETOOTH_CONFIG, configJson)&#13;&#10;            .apply()&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存完整配置组合&#13;&#10;    fun saveConfig(name: String) {&#13;&#10;        val deviceConfig = DeviceConfig(&#13;&#10;            name = name,&#13;&#10;            mqttConfig = _mqttConfig.value,&#13;&#10;            bluetoothConfig = _bluetoothConfig.value&#13;&#10;        )&#13;&#10;&#13;&#10;        // 保存配置到SharedPreferences&#13;&#10;        val configJson = gson.toJson(deviceConfig)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_CONFIG_PREFIX + name, configJson)&#13;&#10;            .apply()&#13;&#10;&#13;&#10;        // 更新配置列表&#13;&#10;        val currentList = _configList.value.toMutableList()&#13;&#10;        if (!currentList.contains(name)) {&#13;&#10;            currentList.add(name)&#13;&#10;            _configList.value = currentList&#13;&#10;            saveConfigList(currentList)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载完整配置组合&#13;&#10;    fun loadConfig(name: String) {&#13;&#10;        val configJson = preferences.getString(KEY_CONFIG_PREFIX + name, null)&#13;&#10;        if (configJson != null) {&#13;&#10;            try {&#13;&#10;                val deviceConfig = gson.fromJson(configJson, DeviceConfig::class.java)&#13;&#10;                if (deviceConfig != null) {&#13;&#10;                    updateMqttConfig(deviceConfig.mqttConfig)&#13;&#10;                    updateBluetoothConfig(deviceConfig.bluetoothConfig)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // 加载失败，保持当前配置&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 删除保存的配置&#13;&#10;    fun deleteConfig(name: String) {&#13;&#10;        preferences.edit()&#13;&#10;            .remove(KEY_CONFIG_PREFIX + name)&#13;&#10;            .apply()&#13;&#10;&#13;&#10;        val currentList = _configList.value.toMutableList()&#13;&#10;        currentList.remove(name)&#13;&#10;        _configList.value = currentList&#13;&#10;        saveConfigList(currentList)&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存配置列表&#13;&#10;    private fun saveConfigList(list: List&lt;String&gt;) {&#13;&#10;        val listJson = gson.toJson(list)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_CONFIG_LIST, listJson)&#13;&#10;            .apply()&#13;&#10;    }&#13;&#10;&#13;&#10;    // 获取当前MQTT配置（用于其他组件访问）&#13;&#10;    fun getCurrentMqttConfig(): MqttConfig = _mqttConfig.value&#13;&#10;&#13;&#10;    // 获取当前蓝牙配置（用于其他组件访问）&#13;&#10;    fun getCurrentBluetoothConfig(): BluetoothConfig = _bluetoothConfig.value&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/DeviceDataManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/DeviceDataManager.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.State&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlin.random.Random&#10;&#10;// 设备数据类&#10;data class DeviceData(&#10;    val temperature: Float,&#10;    val humidity: Float,&#10;    val foodAmount: Float,&#10;    val waterAmount: Float,&#10;    val ventilationStatus: Boolean = false,&#10;    val disinfectionStatus: Boolean = false,&#10;    val heatingStatus: Boolean = false,&#10;    val targetTemperature: Float = 25f,&#10;    val lastUpdateTime: String = getCurrentTime()&#10;)&#10;&#10;// 获取当前时间&#10;private fun getCurrentTime(): String {&#10;    val formatter = java.text.SimpleDateFormat(&quot;HH:mm&quot;, java.util.Locale.getDefault())&#10;    return formatter.format(java.util.Date())&#10;}&#10;&#10;// 设备数据管理器（单例模式）&#10;class DeviceDataManager private constructor() {&#10;&#10;    // 使用StateFlow管理数据状态&#10;    private val _deviceData = MutableStateFlow(&#10;        DeviceData(&#10;            temperature = MockDataGenerator.getCurrentValue(DataType.TEMPERATURE),&#10;            humidity = MockDataGenerator.getCurrentValue(DataType.HUMIDITY),&#10;            foodAmount = MockDataGenerator.getCurrentValue(DataType.FOOD),&#10;            waterAmount = MockDataGenerator.getCurrentValue(DataType.WATER)&#10;        )&#10;    )&#10;    val deviceData: StateFlow&lt;DeviceData&gt; = _deviceData.asStateFlow()&#10;&#10;    // 连接状态&#10;    private val _connectionStatus = MutableStateFlow&lt;String?&gt;(null)&#10;    val connectionStatus: StateFlow&lt;String?&gt; = _connectionStatus.asStateFlow()&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DeviceDataManager? = null&#10;&#10;        fun getInstance(): DeviceDataManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DeviceDataManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    // 更新设备数据&#10;    fun updateDeviceData(newData: DeviceData) {&#10;        _deviceData.value = newData.copy(lastUpdateTime = getCurrentTime())&#10;    }&#10;&#10;    // 更新单个数据项&#10;    fun updateTemperature(temperature: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            temperature = temperature,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateHumidity(humidity: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            humidity = humidity,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateFoodAmount(amount: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            foodAmount = amount,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateWaterAmount(amount: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            waterAmount = amount,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    // 更新设备状态&#10;    fun updateVentilationStatus(status: Boolean) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            ventilationStatus = status,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateDisinfectionStatus(status: Boolean) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            disinfectionStatus = status,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateHeatingStatus(status: Boolean) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            heatingStatus = status,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateTargetTemperature(temperature: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            targetTemperature = temperature,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    // 更新连接状态&#10;    fun updateConnectionStatus(status: String?) {&#10;        _connectionStatus.value = status&#10;    }&#10;&#10;    // 模拟数据更新（用于测试）&#10;//    fun simulateDataUpdate() {&#10;//        val currentData = _deviceData.value&#10;//        val newData = currentData.copy(&#10;//            temperature = (currentData.temperature + (Random.nextFloat() - 0.5f) * 2).coerceIn(15f, 35f),&#10;//            humidity = (currentData.humidity + (Random.nextFloat() - 0.5f) * 5).coerceIn(40f, 85f),&#10;//            foodAmount = maxOf(0f, currentData.foodAmount - Random.nextFloat() * 10),&#10;//            waterAmount = maxOf(0f, currentData.waterAmount - Random.nextFloat() * 15),&#10;//            lastUpdateTime = getCurrentTime()&#10;//        )&#10;//        _deviceData.value = newData&#10;//    }&#10;&#10;    // 获取指定数据类型的当前值&#10;    fun getCurrentValue(dataType: DataType): Float {&#10;        return when (dataType) {&#10;            DataType.TEMPERATURE -&gt; _deviceData.value.temperature&#10;            DataType.HUMIDITY -&gt; _deviceData.value.humidity&#10;            DataType.FOOD -&gt; _deviceData.value.foodAmount&#10;            DataType.WATER -&gt; _deviceData.value.waterAmount&#10;        }&#10;    }&#10;&#10;    // 新增方法：定时更新设备数据以模拟真实数据变化&#10;    fun startPeriodicDataUpdate() {&#10;        // 这个方法可以在MainActivity中调用，定时更新数据&#10;        // 暂时留空，实际应用中可以结合协程实现定时更新&#10;    }&#10;&#10;    // 新增方法：刷新当前数据&#10;    fun refreshCurrentData() {&#10;        MockDataGenerator.clearCache() // 清除缓存以获取新的随机数据&#10;        _deviceData.value = _deviceData.value.copy(&#10;            temperature = MockDataGenerator.getCurrentValue(DataType.TEMPERATURE),&#10;            humidity = MockDataGenerator.getCurrentValue(DataType.HUMIDITY),&#10;            foodAmount = MockDataGenerator.getCurrentValue(DataType.FOOD),&#10;            waterAmount = MockDataGenerator.getCurrentValue(DataType.WATER),&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;}&#10;&#10;// 数据类型枚举（移动到这里以便共享）&#10;enum class DataType(val title: String, val unit: String, val color: androidx.compose.ui.graphics.Color) {&#10;    TEMPERATURE(&quot;温度&quot;, &quot;°C&quot;, androidx.compose.ui.graphics.Color.Red),&#10;    HUMIDITY(&quot;湿度&quot;, &quot;%&quot;, androidx.compose.ui.graphics.Color.Blue),&#10;    FOOD(&quot;食物量&quot;, &quot;g&quot;, androidx.compose.ui.graphics.Color.Green),&#10;    WATER(&quot;水量&quot;, &quot;ml&quot;, androidx.compose.ui.graphics.Color.Cyan)&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#10;&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.State&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlin.random.Random&#10;&#10;// 设备数据类&#10;data class DeviceData(&#10;    val temperature: Float,&#10;    val humidity: Float,&#10;    val foodAmount: Float,&#10;    val waterAmount: Float,&#10;    val ventilationStatus: Boolean = false,&#10;    val disinfectionStatus: Boolean = false,&#10;    val heatingStatus: Boolean = false,&#10;    val targetTemperature: Float = 25f,&#10;    val lastUpdateTime: String = getCurrentTime()&#10;)&#10;&#10;// 获取当前时间&#10;private fun getCurrentTime(): String {&#10;    val formatter = java.text.SimpleDateFormat(&quot;HH:mm&quot;, java.util.Locale.getDefault())&#10;    return formatter.format(java.util.Date())&#10;}&#10;&#10;// 设备数据管理器（单例模式）&#10;class DeviceDataManager private constructor() {&#10;&#10;    // 使用StateFlow管理数据状态，初始化时使用统一的数据生成器&#10;    private val _deviceData = MutableStateFlow(&#10;        DeviceData(&#10;            temperature = MockDataGenerator.getCurrentValue(DataType.TEMPERATURE),&#10;            humidity = MockDataGenerator.getCurrentValue(DataType.HUMIDITY),&#10;            foodAmount = MockDataGenerator.getCurrentValue(DataType.FOOD),&#10;            waterAmount = MockDataGenerator.getCurrentValue(DataType.WATER)&#10;        )&#10;    )&#10;    val deviceData: StateFlow&lt;DeviceData&gt; = _deviceData.asStateFlow()&#10;&#10;    // 连接状态&#10;    private val _connectionStatus = MutableStateFlow&lt;String?&gt;(null)&#10;    val connectionStatus: StateFlow&lt;String?&gt; = _connectionStatus.asStateFlow()&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DeviceDataManager? = null&#10;&#10;        fun getInstance(): DeviceDataManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DeviceDataManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    // 更新设备数据&#10;    fun updateDeviceData(newData: DeviceData) {&#10;        _deviceData.value = newData.copy(lastUpdateTime = getCurrentTime())&#10;    }&#10;&#10;    // 更新单个数据项&#10;    fun updateTemperature(temperature: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            temperature = temperature,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateHumidity(humidity: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            humidity = humidity,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateFoodAmount(amount: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            foodAmount = amount,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateWaterAmount(amount: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            waterAmount = amount,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    // 更新设备状态&#10;    fun updateVentilationStatus(status: Boolean) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            ventilationStatus = status,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateDisinfectionStatus(status: Boolean) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            disinfectionStatus = status,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateHeatingStatus(status: Boolean) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            heatingStatus = status,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    fun updateTargetTemperature(temperature: Float) {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            targetTemperature = temperature,&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    // 更新连接状态&#10;    fun updateConnectionStatus(status: String?) {&#10;        _connectionStatus.value = status&#10;    }&#10;&#10;    // 模拟数据更新（用于测试）&#10;//    fun simulateDataUpdate() {&#10;//        val currentData = _deviceData.value&#10;//        val newData = currentData.copy(&#10;//            temperature = (currentData.temperature + (Random.nextFloat() - 0.5f) * 2).coerceIn(15f, 35f),&#10;//            humidity = (currentData.humidity + (Random.nextFloat() - 0.5f) * 5).coerceIn(40f, 85f),&#10;//            foodAmount = maxOf(0f, currentData.foodAmount - Random.nextFloat() * 10),&#10;//            waterAmount = maxOf(0f, currentData.waterAmount - Random.nextFloat() * 15),&#10;//            lastUpdateTime = getCurrentTime()&#10;//        )&#10;//        _deviceData.value = newData&#10;//    }&#10;&#10;    // 获取指定数据类型的当前值&#10;    fun getCurrentValue(dataType: DataType): Float {&#10;        return when (dataType) {&#10;            DataType.TEMPERATURE -&gt; _deviceData.value.temperature&#10;            DataType.HUMIDITY -&gt; _deviceData.value.humidity&#10;            DataType.FOOD -&gt; _deviceData.value.foodAmount&#10;            DataType.WATER -&gt; _deviceData.value.waterAmount&#10;        }&#10;    }&#10;&#10;    // 新增方法：刷新当前数据，确保与图表数据同步&#10;    fun refreshCurrentData() {&#10;        MockDataGenerator.clearCache() // 清除缓存以获取新的随机数据&#10;        _deviceData.value = _deviceData.value.copy(&#10;            temperature = MockDataGenerator.getCurrentValue(DataType.TEMPERATURE),&#10;            humidity = MockDataGenerator.getCurrentValue(DataType.HUMIDITY),&#10;            foodAmount = MockDataGenerator.getCurrentValue(DataType.FOOD),&#10;            waterAmount = MockDataGenerator.getCurrentValue(DataType.WATER),&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;&#10;    // 新增方法：定期更新数据以保持同步&#10;    fun updateWithCurrentValues() {&#10;        _deviceData.value = _deviceData.value.copy(&#10;            temperature = MockDataGenerator.getCurrentValue(DataType.TEMPERATURE),&#10;            humidity = MockDataGenerator.getCurrentValue(DataType.HUMIDITY),&#10;            foodAmount = MockDataGenerator.getCurrentValue(DataType.FOOD),&#10;            waterAmount = MockDataGenerator.getCurrentValue(DataType.WATER),&#10;            lastUpdateTime = getCurrentTime()&#10;        )&#10;    }&#10;}&#10;&#10;// 数据类型枚举（移动到这里以便共享）&#10;enum class DataType(val title: String, val unit: String, val color: androidx.compose.ui.graphics.Color) {&#10;    TEMPERATURE(&quot;温度&quot;, &quot;°C&quot;, androidx.compose.ui.graphics.Color.Red),&#10;    HUMIDITY(&quot;湿度&quot;, &quot;%&quot;, androidx.compose.ui.graphics.Color.Blue),&#10;    FOOD(&quot;食物量&quot;, &quot;g&quot;, androidx.compose.ui.graphics.Color.Green),&#10;    WATER(&quot;水量&quot;, &quot;ml&quot;, androidx.compose.ui.graphics.Color.Cyan)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/MockDataGenerator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/MockDataGenerator.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;/**&#10; * 统一的模拟数据生成器&#10; * 确保设备页面和详细页面的数据一致性&#10; */&#10;object MockDataGenerator {&#10;&#10;    // 数据缓存，确保同一时间点的数据一致&#10;    private val dataCache = mutableMapOf&lt;String, Float&gt;()&#10;&#10;    /**&#10;     * 生成温度数据&#10;     * 模拟真实的温度变化规律：&#10;     * - 白天（6:00-18:00）温度较高&#10;     * - 夜晚（18:00-6:00）温度较低&#10;     * - 有合理的随机波动&#10;     * - 温度范围在24-30度之间&#10;     */&#10;    fun generateTemperatureValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;temp_${hour}_${minute}&quot;&#10;&#10;        return dataCache.getOrPut(timeKey) {&#10;            // 基础温度曲线：使用正弦函数模拟日夜温差，调整为24-30度范围&#10;            val baseTemp = 27f + 3f * sin((hour - 6) * PI / 12).toFloat()&#10;&#10;            // 添加小幅随机波动 (±0.8°C)&#10;            val noise = (Random.nextFloat() - 0.5f) * 1.6f&#10;&#10;            // 确保温度在合理范围内24-30度&#10;            (baseTemp + noise).coerceIn(24f, 30f)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成湿度数据&#10;     * 模拟真实的湿度变化规律：&#10;     * - 早晨湿度较高&#10;     * - 中午湿度较低&#10;     * - 傍晚湿度回升&#10;     */&#10;    fun generateHumidityValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;humidity_${hour}_${minute}&quot;&#10;&#10;        return dataCache.getOrPut(timeKey) {&#10;            // 基础湿度曲线：早晚高，中午低&#10;            val baseHumidity = 65f + 12f * cos((hour - 2) * PI / 12).toFloat()&#10;&#10;            // 添加随机波动 (±3%)&#10;            val noise = (Random.nextFloat() - 0.5f) * 6f&#10;&#10;            // 确保湿度在合理范围内&#10;            (baseHumidity + noise).coerceIn(45f, 80f)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成食物量数据&#10;     * 模拟真实的喂食规律：&#10;     * - 每天4次喂食：7:00, 13:00, 19:00, 1:00（凌晨补充）&#10;     * - 喂食后食物量快速增加到最大值&#10;     * - 分段消耗，但每次消耗量有随机性&#10;     */&#10;    fun generateFoodValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;food_${hour}_${minute}&quot;&#10;&#10;        return dataCache.getOrPut(timeKey) {&#10;            val currentTime = hour * 60 + minute&#10;&#10;            // 喂食时间点：1:00(凌晨), 7:00, 13:00, 19:00&#10;            val feedingTimes = listOf(1 * 60, 7 * 60, 13 * 60, 19 * 60)&#10;&#10;            // 找到最近的喂食时间&#10;            val lastFeedingTime = feedingTimes.lastOrNull { it &lt;= currentTime }&#10;                ?: (feedingTimes.last() - 24 * 60) // 如果是凌晨1点前，则是昨天19点&#10;&#10;            // 计算距离上次喂食的时间（分钟）&#10;            val timeSinceFeeding = if (lastFeedingTime &lt; 0) {&#10;                currentTime + (24 * 60 + lastFeedingTime)&#10;            } else {&#10;                currentTime - lastFeedingTime&#10;            }&#10;&#10;            // 基于时间的渐进式消耗，模拟宠物间歇性进食&#10;            val maxAmount = 450f&#10;            val timeHours = timeSinceFeeding / 60f&#10;&#10;            // 使用指数衰减函数模拟食物消耗，加入随机性&#10;            val decayRate = 0.3f + Random.nextFloat() * 0.2f // 0.3-0.5的衰减率&#10;            val randomConsumption = Random.nextFloat() * 0.3f + 0.1f // 额外的随机消耗10-40%&#10;&#10;            // 计算剩余食物量：基础衰减 + 随机消耗&#10;            val baseRemaining = maxAmount * exp(-decayRate * timeHours)&#10;            val randomReduction = baseRemaining * randomConsumption * (timeHours / 6f) // 时间越长，随机消耗越多&#10;&#10;            val currentAmount = (baseRemaining - randomReduction).coerceIn(20f, maxAmount)&#10;&#10;            // 在特定时间段增加一些波动（模拟宠物活跃期）&#10;            val activityBonus = when (hour) {&#10;                in 6..8, in 17..19 -&gt; Random.nextFloat() * 15f - 30f // 活跃期消耗更多&#10;                in 22..23, in 0..5 -&gt; Random.nextFloat() * 10f // 休息期消耗较少&#10;                else -&gt; Random.nextFloat() * 20f - 10f&#10;            }&#10;&#10;            (currentAmount + activityBonus).coerceIn(0f, maxAmount)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成水量数据&#10;     * 模拟真实的饮水规律：&#10;     * - 每天3次加水：0:00(凌晨), 8:00, 16:00&#10;     * - 加水后水量快速增加到最大值&#10;     * - 分段消耗，但每次消耗量有随机性，受温度影响&#10;     */&#10;    fun generateWaterValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;water_${hour}_${minute}&quot;&#10;&#10;        return dataCache.getOrPut(timeKey) {&#10;            val currentTime = hour * 60 + minute&#10;&#10;            // 加水时间点：0:00(凌晨), 8:00, 16:00&#10;            val refillTimes = listOf(0 * 60, 8 * 60, 16 * 60)&#10;&#10;            // 找到最近的加水时间&#10;            val lastRefillTime = refillTimes.lastOrNull { it &lt;= currentTime }&#10;                ?: (refillTimes.last() - 24 * 60) // 如果是凌晨0点前，则是昨天16点&#10;&#10;            // 计算距离上次加水的时间（分钟）&#10;            val timeSinceRefill = if (lastRefillTime &lt; 0) {&#10;                currentTime + (24 * 60 + lastRefillTime)&#10;            } else {&#10;                currentTime - lastRefillTime&#10;            }&#10;&#10;            val maxAmount = 400f&#10;            val timeHours = timeSinceRefill / 60f&#10;&#10;            // 水的消耗受温度影响&#10;            val currentTemp = generateTemperatureValue(hour, minute)&#10;            val tempFactor = 1f + (currentTemp - 27f) * 0.05f // 温度每高1度，消耗增加5%&#10;&#10;            // 使用更快的衰减率模拟水的快速消耗&#10;            val baseDecayRate = 0.4f + Random.nextFloat() * 0.3f // 0.4-0.7的衰减率&#10;            val tempAdjustedDecayRate = baseDecayRate * tempFactor&#10;&#10;            // 计算基础剩余水量&#10;            val baseRemaining = maxAmount * exp(-tempAdjustedDecayRate * timeHours)&#10;&#10;            // 随机消耗（模拟宠物不规律的饮水习惯）&#10;            val randomConsumption = Random.nextFloat() * 0.4f + 0.1f // 10-50%的随机消耗&#10;            val randomReduction = baseRemaining * randomConsumption * (timeHours / 8f)&#10;&#10;            val currentAmount = (baseRemaining - randomReduction).coerceIn(15f, maxAmount)&#10;&#10;            // 活动期和温度调整&#10;            val activityAndTempBonus = when (hour) {&#10;                in 10..14 -&gt; -(Random.nextFloat() * 25f + 10f) // 中午消耗更多（温度高）&#10;                in 6..8, in 18..20 -&gt; -(Random.nextFloat() * 20f) // 活跃期消耗更多&#10;                in 22..23, in 0..5 -&gt; Random.nextFloat() * 8f // 休息期消耗较少&#10;                else -&gt; Random.nextFloat() * 15f - 7f&#10;            }&#10;&#10;            (currentAmount + activityAndTempBonus).coerceIn(0f, maxAmount)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 清除数据缓存（用于刷新数据）&#10;     */&#10;    fun clearCache() {&#10;        dataCache.clear()&#10;    }&#10;&#10;    /**&#10;     * 获取当前时间的实时数据&#10;     */&#10;    fun getCurrentValue(dataType: DataType): Float {&#10;        val now = LocalDateTime.now()&#10;        return when (dataType) {&#10;            DataType.TEMPERATURE -&gt; generateTemperatureValue(now.hour, now.minute)&#10;            DataType.HUMIDITY -&gt; generateHumidityValue(now.hour, now.minute)&#10;            DataType.FOOD -&gt; generateFoodValue(now.hour, now.minute)&#10;            DataType.WATER -&gt; generateWaterValue(now.hour, now.minute)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成24小时的图表数据（设备页面用）&#10;     */&#10;    fun generate24HourChartData(dataType: DataType): List&lt;ChartDataPoint&gt; {&#10;        return (0..23).map { hour -&gt;&#10;            val value = when (dataType) {&#10;                DataType.TEMPERATURE -&gt; generateTemperatureValue(hour)&#10;                DataType.HUMIDITY -&gt; generateHumidityValue(hour)&#10;                DataType.FOOD -&gt; generateFoodValue(hour)&#10;                DataType.WATER -&gt; generateWaterValue(hour)&#10;            }&#10;            ChartDataPoint(hour, value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成详细数据（详细页面用）&#10;     */&#10;    fun generateDetailData(dataType: DataType, date: LocalDate): List&lt;DetailDataPoint&gt; {&#10;        val data = mutableListOf&lt;DetailDataPoint&gt;()&#10;&#10;        // 每15分钟生成一个数据点&#10;        for (hour in 0..23) {&#10;            for (minute in 0 until 60 step 15) {&#10;                val value = when (dataType) {&#10;                    DataType.TEMPERATURE -&gt; generateTemperatureValue(hour, minute)&#10;                    DataType.HUMIDITY -&gt; generateHumidityValue(hour, minute)&#10;                    DataType.FOOD -&gt; generateFoodValue(hour, minute)&#10;                    DataType.WATER -&gt; generateWaterValue(hour, minute)&#10;                }&#10;&#10;                data.add(&#10;                    DetailDataPoint(&#10;                        hour = hour,&#10;                        minute = minute,&#10;                        value = value,&#10;                        timestamp = String.format(&quot;%02d:%02d&quot;, hour, minute)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        return data&#10;    }&#10;}&#10;&#10;// 数据点类（从DeviceScreen.kt移动到这里）&#10;data class ChartDataPoint(&#10;    val hour: Int,&#10;    val value: Float&#10;)&#10;&#10;// 详细数据点类（从DetailScreen.kt移动到这里）&#10;data class DetailDataPoint(&#10;    val hour: Int,&#10;    val minute: Int,&#10;    val value: Float,&#10;    val timestamp: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#10;&#10;import java.time.LocalDate&#10;import java.time.LocalDateTime&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;/**&#10; * 统一的模拟数据生成器&#10; * 确保设备页面和详细页面的数据一致性&#10; */&#10;object MockDataGenerator {&#10;&#10;    // 数据缓存，确保同一时间点的数据一致&#10;    private val dataCache = mutableMapOf&lt;String, Float&gt;()&#10;&#10;    /**&#10;     * 生成温度数据&#10;     * 模拟真实的温度变化规律：&#10;     * - 白天（6:00-18:00）温度较高&#10;     * - 夜晚（18:00-6:00）温度较低&#10;     * - 有合理的随机波动&#10;     * - 温度范围在24-30度之间&#10;     */&#10;    fun generateTemperatureValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;temp_${hour}_${minute}&quot;&#10;&#10;        return dataCache.getOrPut(timeKey) {&#10;            // 基础温度曲线：使用正弦函数模拟日夜温差，调整为24-30度范围&#10;            val baseTemp = 27f + 3f * sin((hour - 6) * PI / 12).toFloat()&#10;&#10;            // 添加小幅随机波动 (±0.8°C)&#10;            val noise = (Random.nextFloat() - 0.5f) * 1.6f&#10;&#10;            // 确保温度在合理范围内24-30度&#10;            (baseTemp + noise).coerceIn(24f, 30f)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成湿度数据&#10;     * 模拟真实的湿度变化规律：&#10;     * - 早晨湿度较高&#10;     * - 中午湿度较低&#10;     * - 傍晚湿度回升&#10;     */&#10;    fun generateHumidityValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;humidity_${hour}_${minute}&quot;&#10;&#10;        return dataCache.getOrPut(timeKey) {&#10;            // 基础湿度曲线：早晚高，中午低&#10;            val baseHumidity = 65f + 12f * cos((hour - 2) * PI / 12).toFloat()&#10;&#10;            // 添加随机波动 (±3%)&#10;            val noise = (Random.nextFloat() - 0.5f) * 6f&#10;&#10;            // 确保湿度在合理范围内&#10;            (baseHumidity + noise).coerceIn(45f, 80f)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成食物量数据&#10;     * 模拟真实的宠物饮食规律：&#10;     * - 三餐时间：7:00, 13:00, 19:00 食物量高&#10;     * - 凌晨和深夜（0:00-6:00, 22:00-23:59）饮食量非常小&#10;     * - 其他时间饮食量适中&#10;     */&#10;    fun generateFoodValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;food_${hour}_${minute}&quot;&#10;        &#10;        return dataCache.getOrPut(timeKey) {&#10;            val currentTime = hour * 60 + minute&#10;            &#10;            // 三餐时间点：7:00, 13:00, 19:00&#10;            val mealTimes = listOf(7 * 60, 13 * 60, 19 * 60)&#10;            &#10;            // 找到最近的用餐时间&#10;            val lastMealTime = mealTimes.lastOrNull { it &lt;= currentTime } &#10;                ?: (mealTimes.last() - 24 * 60) // 如果是早上7点前，则是昨天19点&#10;            &#10;            // 计算距离上次用餐的时间（分钟）&#10;            val timeSinceMeal = if (lastMealTime &lt; 0) {&#10;                currentTime + (24 * 60 + lastMealTime)&#10;            } else {&#10;                currentTime - lastMealTime&#10;            }&#10;            &#10;            val maxAmount = 400f&#10;            val timeHours = timeSinceMeal / 60f&#10;            &#10;            // 根据时间段调整食物基础量和消耗率&#10;            val (baseMultiplier, consumptionRate) = when (hour) {&#10;                // 凌晨和深夜：饮食量非常小&#10;                in 0..5, in 22..23 -&gt; Pair(0.1f, 0.05f)&#10;                // 三餐时间前后1小时：饮食量高&#10;                in 6..8, in 12..14, in 18..20 -&gt; Pair(1.0f, 0.3f)&#10;                // 其他时间：饮食量适中&#10;                else -&gt; Pair(0.4f, 0.2f)&#10;            }&#10;            &#10;            // 使用指数衰减模拟食物消耗&#10;            val adjustedConsumptionRate = consumptionRate + Random.nextFloat() * 0.1f&#10;            val baseRemaining = maxAmount * baseMultiplier * exp(-adjustedConsumptionRate * timeHours)&#10;            &#10;            // 在用餐时间点附近，食物量会增加&#10;            val mealBonus = if (mealTimes.any { abs(currentTime - it) &lt;= 30 }) { // 用餐前后30分钟&#10;                Random.nextFloat() * 100f + 50f&#10;            } else 0f&#10;            &#10;            // 添加随机波动&#10;            val randomVariation = (Random.nextFloat() - 0.5f) * 20f&#10;            &#10;            val currentAmount = baseRemaining + mealBonus + randomVariation&#10;            &#10;            currentAmount.coerceIn(0f, maxAmount)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * 生成水量数据&#10;     * 模拟真实的宠物饮水规律：&#10;     * - 活跃时间（6:00-9:00, 16:00-20:00）饮水量高&#10;     * - 凌晨和深夜（0:00-5:00, 21:00-23:59）饮水量非常小&#10;     * - 其他时间饮水量适中&#10;     * - 受温度影响&#10;     */&#10;    fun generateWaterValue(hour: Int, minute: Int = 0): Float {&#10;        val timeKey = &quot;water_${hour}_${minute}&quot;&#10;        &#10;        return dataCache.getOrPut(timeKey) {&#10;            val currentTime = hour * 60 + minute&#10;            &#10;            // 主要饮水时间点：8:00, 16:00&#10;            val drinkTimes = listOf(8 * 60, 16 * 60)&#10;            &#10;            // 找到最近的饮水时间&#10;            val lastDrinkTime = drinkTimes.lastOrNull { it &lt;= currentTime }&#10;                ?: (drinkTimes.last() - 24 * 60) // 如果是早上8点前，则是昨天16点&#10;            &#10;            // 计算距离上次主要饮水的时间（分钟）&#10;            val timeSinceDrink = if (lastDrinkTime &lt; 0) {&#10;                currentTime + (24 * 60 + lastDrinkTime)&#10;            } else {&#10;                currentTime - lastDrinkTime&#10;            }&#10;            &#10;            val maxAmount = 350f&#10;            val timeHours = timeSinceDrink / 60f&#10;            &#10;            // 获取当前温度影响&#10;            val currentTemp = generateTemperatureValue(hour, minute)&#10;            val tempFactor = 1f + (currentTemp - 27f) * 0.08f // 温度每高1度，需水量增加8%&#10;            &#10;            // 根据时间段调整水量基础量和消耗率&#10;            val (baseMultiplier, consumptionRate) = when (hour) {&#10;                // 凌晨和深夜：饮水量非常小&#10;                in 0..5, in 21..23 -&gt; Pair(0.15f, 0.02f)&#10;                // 活跃时间：饮水量高&#10;                in 6..9, in 16..20 -&gt; Pair(1.0f, 0.4f)&#10;                // 中午高温时间：饮水量较高&#10;                in 10..15 -&gt; Pair(0.8f, 0.5f)&#10;                else -&gt; Pair(0.5f, 0.3f)&#10;            }&#10;            &#10;            // 使用指数衰减模拟水量消耗，考虑温度因素&#10;            val adjustedConsumptionRate = (consumptionRate * tempFactor) + Random.nextFloat() * 0.15f&#10;            val baseRemaining = maxAmount * baseMultiplier * exp(-adjustedConsumptionRate * timeHours)&#10;            &#10;            // 在主要饮水时间点附近，水量会增加&#10;            val drinkBonus = if (drinkTimes.any { abs(currentTime - it) &lt;= 45 }) { // 饮水前后45分钟&#10;                Random.nextFloat() * 80f + 40f&#10;            } else 0f&#10;            &#10;            // 温度相关的额外消耗/补充&#10;            val tempAdjustment = when {&#10;                currentTemp &gt; 28f -&gt; -(Random.nextFloat() * 15f) // 高温时额外消耗&#10;                currentTemp &lt; 25f -&gt; Random.nextFloat() * 8f    // 低温时消耗减少&#10;                else -&gt; 0f&#10;            }&#10;            &#10;            // 添加随机波动&#10;            val randomVariation = (Random.nextFloat() - 0.5f) * 25f&#10;            &#10;            val currentAmount = baseRemaining + drinkBonus + tempAdjustment + randomVariation&#10;            &#10;            currentAmount.coerceIn(0f, maxAmount)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 清除数据缓存（用于刷新数据）&#10;     */&#10;    fun clearCache() {&#10;        dataCache.clear()&#10;    }&#10;&#10;    /**&#10;     * 获取当前时间的实时数据&#10;     */&#10;    fun getCurrentValue(dataType: DataType): Float {&#10;        val now = LocalDateTime.now()&#10;        return when (dataType) {&#10;            DataType.TEMPERATURE -&gt; generateTemperatureValue(now.hour, now.minute)&#10;            DataType.HUMIDITY -&gt; generateHumidityValue(now.hour, now.minute)&#10;            DataType.FOOD -&gt; generateFoodValue(now.hour, now.minute)&#10;            DataType.WATER -&gt; generateWaterValue(now.hour, now.minute)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成24小时的图表数据（设备页面用）&#10;     */&#10;    fun generate24HourChartData(dataType: DataType): List&lt;ChartDataPoint&gt; {&#10;        return (0..23).map { hour -&gt;&#10;            val value = when (dataType) {&#10;                DataType.TEMPERATURE -&gt; generateTemperatureValue(hour)&#10;                DataType.HUMIDITY -&gt; generateHumidityValue(hour)&#10;                DataType.FOOD -&gt; generateFoodValue(hour)&#10;                DataType.WATER -&gt; generateWaterValue(hour)&#10;            }&#10;            ChartDataPoint(hour, value)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成详细数据（详细页面用）&#10;     */&#10;    fun generateDetailData(dataType: DataType, date: LocalDate): List&lt;DetailDataPoint&gt; {&#10;        val data = mutableListOf&lt;DetailDataPoint&gt;()&#10;&#10;        // 每15分钟生成一个数据点&#10;        for (hour in 0..23) {&#10;            for (minute in 0 until 60 step 15) {&#10;                val value = when (dataType) {&#10;                    DataType.TEMPERATURE -&gt; generateTemperatureValue(hour, minute)&#10;                    DataType.HUMIDITY -&gt; generateHumidityValue(hour, minute)&#10;                    DataType.FOOD -&gt; generateFoodValue(hour, minute)&#10;                    DataType.WATER -&gt; generateWaterValue(hour, minute)&#10;                }&#10;&#10;                data.add(&#10;                    DetailDataPoint(&#10;                        hour = hour,&#10;                        minute = minute,&#10;                        value = value,&#10;                        timestamp = String.format(&quot;%02d:%02d&quot;, hour, minute)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        return data&#10;    }&#10;}&#10;&#10;// 数据点类（从DeviceScreen.kt移动到这里）&#10;data class ChartDataPoint(&#10;    val hour: Int,&#10;    val value: Float&#10;)&#10;&#10;// 详细数据点类（从DetailScreen.kt移动到这里）&#10;data class DetailDataPoint(&#10;    val hour: Int,&#10;    val minute: Int,&#10;    val value: Float,&#10;    val timestamp: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/screens/DetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/screens/DetailScreen.kt" />
              <option name="originalContent" value="package com.example.petnestiq.screens&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.StrokeJoin&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.example.petnestiq.data.DataType&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;// 详细数据点&#10;data class DetailDataPoint(&#10;    val hour: Int,&#10;    val minute: Int,&#10;    val value: Float,&#10;    val timestamp: String&#10;)&#10;&#10;// 今日概览数据&#10;data class DailySummary(&#10;    val maxValue: Float,&#10;    val minValue: Float,&#10;    val avgValue: Float,&#10;    val maxTime: String,&#10;    val minTime: String&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DetailScreen(&#10;    dataType: DataType,&#10;    onBackClick: () -&gt; Unit&#10;) {&#10;    // 获取数据管理器实例&#10;    val deviceDataManager = remember { DeviceDataManager.getInstance() }&#10;    val deviceData by deviceDataManager.deviceData.collectAsStateWithLifecycle()&#10;&#10;    var selectedDate by remember { mutableStateOf(LocalDate.now()) }&#10;    var showDatePicker by remember { mutableStateOf(false) }&#10;&#10;    // 生成模拟详细数据&#10;    val detailData = remember(selectedDate, dataType) {&#10;        generateDetailData(dataType, selectedDate)&#10;    }&#10;&#10;    // 计算今日概览&#10;    val dailySummary = remember(detailData) {&#10;        calculateDailySummary(detailData)&#10;    }&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        // 顶部导航栏&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(&#10;                onClick = onBackClick,&#10;                modifier = Modifier.size(40.dp)&#10;            ) {&#10;                Icon(&#10;                    Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;返回&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            Text(&#10;                text = &quot;${dataType.title}详情&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary,&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 日期选择器&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable { showDatePicker = true },&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;选择日期: ${selectedDate.format(DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;))}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Icon(&#10;                    Icons.Default.DateRange,&#10;                    contentDescription = &quot;选择日期&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 当前数据显示&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.background&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(20.dp),&#10;                horizontalAlignment = Alignment.Start&#10;            ) {&#10;                Text(&#10;                    text = when (dataType) {&#10;                        DataType.TEMPERATURE -&gt; &quot;${deviceData.temperature.toInt()}${dataType.unit}&quot;&#10;                        DataType.HUMIDITY -&gt; &quot;${deviceData.humidity.toInt()}${dataType.unit}&quot;&#10;                        DataType.FOOD -&gt; &quot;${deviceData.foodAmount.toInt()}${dataType.unit}&quot;&#10;                        DataType.WATER -&gt; &quot;${deviceData.waterAmount.toInt()}${dataType.unit}&quot;&#10;                    },&#10;                    style = MaterialTheme.typography.displayMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = dataType.color&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = &quot;更新时间: ${deviceData.lastUpdateTime}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 折线图&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;24小时趋势图&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                DetailChart(&#10;                    data = detailData,&#10;                    lineColor = dataType.color,&#10;                    unit = dataType.unit,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(200.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 今日概览&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;今日概览&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceEvenly&#10;                ) {&#10;                    SummaryItem(&#10;                        label = &quot;最高&quot;,&#10;                        value = &quot;${dailySummary.maxValue.toInt()}${dataType.unit}&quot;,&#10;                        time = dailySummary.maxTime,&#10;                        color = Color(0xFFE57373)&#10;                    )&#10;&#10;                    SummaryItem(&#10;                        label = &quot;最低&quot;,&#10;                        value = &quot;${dailySummary.minValue.toInt()}${dataType.unit}&quot;,&#10;                        time = dailySummary.minTime,&#10;                        color = Color(0xFF64B5F6)&#10;                    )&#10;&#10;                    SummaryItem(&#10;                        label = &quot;平均&quot;,&#10;                        value = &quot;${dailySummary.avgValue.toInt()}${dataType.unit}&quot;,&#10;                        time = &quot;全天&quot;,&#10;                        color = Color(0xFF81C784)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // 日期选择器弹窗&#10;    if (showDatePicker) {&#10;        CustomDatePickerDialog(&#10;            onDateSelected = { date -&gt;&#10;                selectedDate = date&#10;                showDatePicker = false&#10;            },&#10;            onDismiss = { showDatePicker = false }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SummaryItem(&#10;    label: String,&#10;    value: String,&#10;    time: String,&#10;    color: Color&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .size(8.dp)&#10;                .clip(CircleShape)&#10;                .background(color)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSecondaryContainer&#10;        )&#10;&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.titleSmall,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSecondaryContainer&#10;        )&#10;&#10;        Text(&#10;            text = time,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSecondaryContainer.copy(alpha = 0.7f)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DetailChart(&#10;    data: List&lt;DetailDataPoint&gt;,&#10;    lineColor: Color,&#10;    unit: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val textColor = MaterialTheme.colorScheme.onSurface&#10;&#10;    Canvas(modifier = modifier) {&#10;        if (data.isEmpty()) return@Canvas&#10;&#10;        val width = size.width&#10;        val height = size.height&#10;        val padding = 32.dp.toPx()&#10;&#10;        // 计算数据范围&#10;        val minValue = data.minOf { it.value }&#10;        val maxValue = data.maxOf { it.value }&#10;        val valueRange = if (maxValue &gt; minValue) maxValue - minValue else 1f&#10;&#10;        // 计算图表区域&#10;        val chartWidth = width - 2 * padding&#10;        val chartHeight = height - 2 * padding&#10;&#10;        // 创建路径&#10;        val path = Path()&#10;&#10;        data.forEachIndexed { index, point -&gt;&#10;            val x = padding + chartWidth * (point.hour + point.minute / 60f) / 24f&#10;            val y = padding + chartHeight * (1 - (point.value - minValue) / valueRange)&#10;&#10;            if (index == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;&#10;        // 绘制网格线&#10;        drawIntoCanvas { canvas -&gt;&#10;            val gridPaint = android.graphics.Paint().apply {&#10;                color = Color.Gray.copy(alpha = 0.3f).toArgb()&#10;                strokeWidth = 1.dp.toPx()&#10;            }&#10;&#10;            // 垂直网格线 (时间)&#10;            for (hour in 0..24 step 6) {&#10;                val x = padding + chartWidth * hour / 24f&#10;                canvas.nativeCanvas.drawLine(x, padding, x, height - padding, gridPaint)&#10;            }&#10;&#10;            // 水平网格线 (数值)&#10;            for (i in 0..4) {&#10;                val y = padding + chartHeight * i / 4f&#10;                canvas.nativeCanvas.drawLine(padding, y, width - padding, y, gridPaint)&#10;            }&#10;        }&#10;&#10;        // 绘制曲线&#10;        drawPath(&#10;            path = path,&#10;            color = lineColor,&#10;            style = Stroke(&#10;                width = 2.dp.toPx(),&#10;                cap = StrokeCap.Round,&#10;                join = StrokeJoin.Round&#10;            )&#10;        )&#10;&#10;        // 绘制数据点&#10;        data.forEach { point -&gt;&#10;            val x = padding + chartWidth * (point.hour + point.minute / 60f) / 24f&#10;            val y = padding + chartHeight * (1 - (point.value - minValue) / valueRange)&#10;&#10;            drawCircle(&#10;                color = lineColor,&#10;                radius = 3.dp.toPx(),&#10;                center = Offset(x, y)&#10;            )&#10;        }&#10;&#10;        // 绘制坐标轴标签&#10;        drawIntoCanvas { canvas -&gt;&#10;            val textPaint = android.graphics.Paint().apply {&#10;                color = textColor.toArgb()&#10;                textSize = 10.sp.toPx()&#10;                isAntiAlias = true&#10;            }&#10;&#10;            // X轴时间标签&#10;            for (hour in 0..24 step 6) {&#10;                val x = padding + chartWidth * hour / 24f&#10;                val y = height - 8.dp.toPx()&#10;                textPaint.textAlign = android.graphics.Paint.Align.CENTER&#10;                canvas.nativeCanvas.drawText(&quot;${hour}:00&quot;, x, y, textPaint)&#10;            }&#10;&#10;            // Y轴数值标签&#10;            for (i in 0..4) {&#10;                val value = minValue + (maxValue - minValue) * (4 - i) / 4f&#10;                val x = 8.dp.toPx()&#10;                val y = padding + chartHeight * i / 4f + 4.dp.toPx()&#10;                textPaint.textAlign = android.graphics.Paint.Align.LEFT&#10;                canvas.nativeCanvas.drawText(&quot;${value.toInt()}$unit&quot;, x, y, textPaint)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun CustomDatePickerDialog(&#10;    onDateSelected: (LocalDate) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    val datePickerState = rememberDatePickerState()&#10;&#10;    DatePickerDialog(&#10;        onDismissRequest = onDismiss,&#10;        confirmButton = {&#10;            TextButton(&#10;                onClick = {&#10;                    datePickerState.selectedDateMillis?.let { millis -&gt;&#10;                        val date = java.time.Instant.ofEpochMilli(millis)&#10;                            .atZone(java.time.ZoneId.systemDefault())&#10;                            .toLocalDate()&#10;                        onDateSelected(date)&#10;                    }&#10;                }&#10;            ) {&#10;                Text(&quot;确定&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;取消&quot;)&#10;            }&#10;        }&#10;    ) {&#10;        DatePicker(state = datePickerState)&#10;    }&#10;}&#10;&#10;// 生成模拟详细数据&#10;fun generateDetailData(dataType: DataType, date: LocalDate): List&lt;DetailDataPoint&gt; {&#10;    val data = mutableListOf&lt;DetailDataPoint&gt;()&#10;&#10;    for (hour in 0..23) {&#10;        for (minute in 0 until 60 step 15) { // 每15分钟一个数据点&#10;            val baseValue = when (dataType) {&#10;                DataType.TEMPERATURE -&gt; 20f + 8f * sin((hour - 6) * Math.PI / 12).toFloat()&#10;                DataType.HUMIDITY -&gt; 60f + 15f * sin((hour - 3) * Math.PI / 12).toFloat()&#10;                DataType.FOOD -&gt; if (hour % 8 == 0 &amp;&amp; minute == 0) 500f else maxOf(0f, 500f - (hour % 8) * 60f - minute * 1f)&#10;                DataType.WATER -&gt; if (hour % 6 == 0 &amp;&amp; minute == 0) 500f else maxOf(0f, 500f - (hour % 6) * 80f - minute * 1.5f)&#10;            }&#10;&#10;            val noise = Random.nextFloat() * 6f - 3f // ±3的随机噪声&#10;            val value = when (dataType) {&#10;                DataType.TEMPERATURE -&gt; (baseValue + noise).coerceIn(15f, 35f)&#10;                DataType.HUMIDITY -&gt; (baseValue + noise).coerceIn(40f, 85f)&#10;                DataType.FOOD -&gt; (baseValue + noise).coerceIn(0f, 500f)&#10;                DataType.WATER -&gt; (baseValue + noise).coerceIn(0f, 500f)&#10;            }&#10;&#10;            data.add(&#10;                DetailDataPoint(&#10;                    hour = hour,&#10;                    minute = minute,&#10;                    value = value,&#10;                    timestamp = String.format(&quot;%02d:%02d&quot;, hour, minute)&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    return data&#10;}&#10;&#10;// 计算今日概览&#10;fun calculateDailySummary(data: List&lt;DetailDataPoint&gt;): DailySummary {&#10;    if (data.isEmpty()) {&#10;        return DailySummary(0f, 0f, 0f, &quot;&quot;, &quot;&quot;)&#10;    }&#10;&#10;    val maxPoint = data.maxByOrNull { it.value }!!&#10;    val minPoint = data.minByOrNull { it.value }!!&#10;    val avgValue = data.map { it.value }.average().toFloat()&#10;&#10;    return DailySummary(&#10;        maxValue = maxPoint.value,&#10;        minValue = minPoint.value,&#10;        avgValue = avgValue,&#10;        maxTime = maxPoint.timestamp,&#10;        minTime = minPoint.timestamp&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.screens&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.DateRange&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.StrokeJoin&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.example.petnestiq.data.DataType&#10;import com.example.petnestiq.data.MockDataGenerator&#10;import com.example.petnestiq.data.DetailDataPoint&#10;import java.time.LocalDate&#10;import java.time.format.DateTimeFormatter&#10;&#10;// 今日概览数据&#10;data class DailySummary(&#10;    val maxValue: Float,&#10;    val minValue: Float,&#10;    val avgValue: Float,&#10;    val maxTime: String,&#10;    val minTime: String&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DetailScreen(&#10;    dataType: DataType,&#10;    onBackClick: () -&gt; Unit&#10;) {&#10;    // 获取数据管理器实例&#10;    val deviceDataManager = remember { DeviceDataManager.getInstance() }&#10;    val deviceData by deviceDataManager.deviceData.collectAsStateWithLifecycle()&#10;&#10;    var selectedDate by remember { mutableStateOf(LocalDate.now()) }&#10;    var showDatePicker by remember { mutableStateOf(false) }&#10;&#10;    // 使用统一的模拟数据生成器&#10;    val detailData = remember(selectedDate, dataType) {&#10;        MockDataGenerator.generateDetailData(dataType, selectedDate)&#10;    }&#10;&#10;    // 计算今日概览&#10;    val dailySummary = remember(detailData) {&#10;        calculateDailySummary(detailData)&#10;    }&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        // 顶部导航栏&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(&#10;                onClick = onBackClick,&#10;                modifier = Modifier.size(40.dp)&#10;            ) {&#10;                Icon(&#10;                    Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;返回&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            Text(&#10;                text = &quot;${dataType.title}详情&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary,&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 日期选择器&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable { showDatePicker = true },&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;选择日期: ${selectedDate.format(DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;))}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Icon(&#10;                    Icons.Default.DateRange,&#10;                    contentDescription = &quot;选择日期&quot;,&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 当前数据显示&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.background&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(20.dp),&#10;                horizontalAlignment = Alignment.Start&#10;            ) {&#10;                Text(&#10;                    text = when (dataType) {&#10;                        DataType.TEMPERATURE -&gt; &quot;${deviceData.temperature.toInt()}${dataType.unit}&quot;&#10;                        DataType.HUMIDITY -&gt; &quot;${deviceData.humidity.toInt()}${dataType.unit}&quot;&#10;                        DataType.FOOD -&gt; &quot;${deviceData.foodAmount.toInt()}${dataType.unit}&quot;&#10;                        DataType.WATER -&gt; &quot;${deviceData.waterAmount.toInt()}${dataType.unit}&quot;&#10;                    },&#10;                    style = MaterialTheme.typography.displayMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = dataType.color&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Text(&#10;                    text = &quot;更新时间: ${deviceData.lastUpdateTime}&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    color = MaterialTheme.colorScheme.onBackground&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 折线图&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;24小时趋势图&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onSurface,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                DetailChart(&#10;                    data = detailData,&#10;                    lineColor = dataType.color,&#10;                    unit = dataType.unit,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(200.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 今日概览&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;今日概览&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceEvenly&#10;                ) {&#10;                    SummaryItem(&#10;                        label = &quot;最高&quot;,&#10;                        value = &quot;${dailySummary.maxValue.toInt()}${dataType.unit}&quot;,&#10;                        time = dailySummary.maxTime,&#10;                        color = Color(0xFFE57373)&#10;                    )&#10;&#10;                    SummaryItem(&#10;                        label = &quot;最低&quot;,&#10;                        value = &quot;${dailySummary.minValue.toInt()}${dataType.unit}&quot;,&#10;                        time = dailySummary.minTime,&#10;                        color = Color(0xFF64B5F6)&#10;                    )&#10;&#10;                    SummaryItem(&#10;                        label = &quot;平均&quot;,&#10;                        value = &quot;${dailySummary.avgValue.toInt()}${dataType.unit}&quot;,&#10;                        time = &quot;全天&quot;,&#10;                        color = Color(0xFF81C784)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // 日期选择器弹窗&#10;    if (showDatePicker) {&#10;        CustomDatePickerDialog(&#10;            onDateSelected = { date -&gt;&#10;                selectedDate = date&#10;                showDatePicker = false&#10;            },&#10;            onDismiss = { showDatePicker = false }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SummaryItem(&#10;    label: String,&#10;    value: String,&#10;    time: String,&#10;    color: Color&#10;) {&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .size(8.dp)&#10;                .clip(CircleShape)&#10;                .background(color)&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSecondaryContainer&#10;        )&#10;&#10;        Text(&#10;            text = value,&#10;            style = MaterialTheme.typography.titleSmall,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.onSecondaryContainer&#10;        )&#10;&#10;        Text(&#10;            text = time,&#10;            style = MaterialTheme.typography.bodySmall,&#10;            color = MaterialTheme.colorScheme.onSecondaryContainer.copy(alpha = 0.7f)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DetailChart(&#10;    data: List&lt;DetailDataPoint&gt;,&#10;    lineColor: Color,&#10;    unit: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val textColor = MaterialTheme.colorScheme.onSurface&#10;&#10;    Canvas(modifier = modifier) {&#10;        if (data.isEmpty()) return@Canvas&#10;&#10;        val width = size.width&#10;        val height = size.height&#10;        val padding = 32.dp.toPx()&#10;&#10;        // 计算数据范围&#10;        val minValue = data.minOf { it.value }&#10;        val maxValue = data.maxOf { it.value }&#10;        val valueRange = if (maxValue &gt; minValue) maxValue - minValue else 1f&#10;&#10;        // 计算图表区域&#10;        val chartWidth = width - 2 * padding&#10;        val chartHeight = height - 2 * padding&#10;&#10;        // 创建路径&#10;        val path = Path()&#10;&#10;        data.forEachIndexed { index, point -&gt;&#10;            val x = padding + chartWidth * (point.hour + point.minute / 60f) / 24f&#10;            val y = padding + chartHeight * (1 - (point.value - minValue) / valueRange)&#10;&#10;            if (index == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;&#10;        // 绘制网格线&#10;        drawIntoCanvas { canvas -&gt;&#10;            val gridPaint = android.graphics.Paint().apply {&#10;                color = Color.Gray.copy(alpha = 0.3f).toArgb()&#10;                strokeWidth = 1.dp.toPx()&#10;            }&#10;&#10;            // 垂直网格线 (时间)&#10;            for (hour in 0..24 step 6) {&#10;                val x = padding + chartWidth * hour / 24f&#10;                canvas.nativeCanvas.drawLine(x, padding, x, height - padding, gridPaint)&#10;            }&#10;&#10;            // 水平网格线 (数值)&#10;            for (i in 0..4) {&#10;                val y = padding + chartHeight * i / 4f&#10;                canvas.nativeCanvas.drawLine(padding, y, width - padding, y, gridPaint)&#10;            }&#10;        }&#10;&#10;        // 绘制曲线&#10;        drawPath(&#10;            path = path,&#10;            color = lineColor,&#10;            style = Stroke(&#10;                width = 2.dp.toPx(),&#10;                cap = StrokeCap.Round,&#10;                join = StrokeJoin.Round&#10;            )&#10;        )&#10;&#10;        // 绘制数据点&#10;        data.forEach { point -&gt;&#10;            val x = padding + chartWidth * (point.hour + point.minute / 60f) / 24f&#10;            val y = padding + chartHeight * (1 - (point.value - minValue) / valueRange)&#10;&#10;            drawCircle(&#10;                color = lineColor,&#10;                radius = 3.dp.toPx(),&#10;                center = Offset(x, y)&#10;            )&#10;        }&#10;&#10;        // 绘制坐标轴标签&#10;        drawIntoCanvas { canvas -&gt;&#10;            val textPaint = android.graphics.Paint().apply {&#10;                color = textColor.toArgb()&#10;                textSize = 10.sp.toPx()&#10;                isAntiAlias = true&#10;            }&#10;&#10;            // X轴时间标签&#10;            for (hour in 0..24 step 6) {&#10;                val x = padding + chartWidth * hour / 24f&#10;                val y = height - 8.dp.toPx()&#10;                textPaint.textAlign = android.graphics.Paint.Align.CENTER&#10;                canvas.nativeCanvas.drawText(&quot;${hour}:00&quot;, x, y, textPaint)&#10;            }&#10;&#10;            // Y轴数值标签&#10;            for (i in 0..4) {&#10;                val value = minValue + (maxValue - minValue) * (4 - i) / 4f&#10;                val x = 8.dp.toPx()&#10;                val y = padding + chartHeight * i / 4f + 4.dp.toPx()&#10;                textPaint.textAlign = android.graphics.Paint.Align.LEFT&#10;                canvas.nativeCanvas.drawText(&quot;${value.toInt()}$unit&quot;, x, y, textPaint)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun CustomDatePickerDialog(&#10;    onDateSelected: (LocalDate) -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    val datePickerState = rememberDatePickerState()&#10;&#10;    DatePickerDialog(&#10;        onDismissRequest = onDismiss,&#10;        confirmButton = {&#10;            TextButton(&#10;                onClick = {&#10;                    datePickerState.selectedDateMillis?.let { millis -&gt;&#10;                        val date = java.time.Instant.ofEpochMilli(millis)&#10;                            .atZone(java.time.ZoneId.systemDefault())&#10;                            .toLocalDate()&#10;                        onDateSelected(date)&#10;                    }&#10;                }&#10;            ) {&#10;                Text(&quot;确定&quot;)&#10;            }&#10;        },&#10;        dismissButton = {&#10;            TextButton(onClick = onDismiss) {&#10;                Text(&quot;取消&quot;)&#10;            }&#10;        }&#10;    ) {&#10;        DatePicker(state = datePickerState)&#10;    }&#10;}&#10;&#10;// 计算今日概览&#10;fun calculateDailySummary(data: List&lt;DetailDataPoint&gt;): DailySummary {&#10;    if (data.isEmpty()) {&#10;        return DailySummary(0f, 0f, 0f, &quot;&quot;, &quot;&quot;)&#10;    }&#10;&#10;    val maxPoint = data.maxByOrNull { it.value }!!&#10;    val minPoint = data.minByOrNull { it.value }!!&#10;    val avgValue = data.map { it.value }.average().toFloat()&#10;&#10;    return DailySummary(&#10;        maxValue = maxPoint.value,&#10;        minValue = minPoint.value,&#10;        avgValue = avgValue,&#10;        maxTime = maxPoint.timestamp,&#10;        minTime = minPoint.timestamp&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/screens/DeviceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/screens/DeviceScreen.kt" />
              <option name="originalContent" value="package com.example.petnestiq.screens&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.MicOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.StrokeJoin&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import com.example.petnestiq.service.AudioRecordManager&#10;import com.example.petnestiq.R&#10;import com.example.petnestiq.navigation.NavigationItem&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.example.petnestiq.data.DataType&#10;import com.example.petnestiq.data.MockDataGenerator&#10;import com.example.petnestiq.data.ChartDataPoint&#10;import com.example.petnestiq.components.VideoStreamPlayer&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DeviceScreen(navController: NavController? = null) {&#10;    // 获取数据管理器实例&#10;    val deviceDataManager = remember { DeviceDataManager.getInstance() }&#10;    val deviceData by deviceDataManager.deviceData.collectAsStateWithLifecycle()&#10;    val connectionStatus by deviceDataManager.connectionStatus.collectAsStateWithLifecycle()&#10;&#10;    // 确保数据同步 - 页面加载时立即同步数据&#10;    LaunchedEffect(Unit) {&#10;        // 清除缓存确保获取最新数据&#10;        MockDataGenerator.clearCache()&#10;        deviceDataManager.updateWithCurrentValues()&#10;    }&#10;&#10;    // 每次重组时确保图表数据和当前值使用相同的时间点&#10;    val currentHour = remember { java.time.LocalDateTime.now().hour }&#10;    val currentMinute = remember { java.time.LocalDateTime.now().minute }&#10;    &#10;    // 生成图表数据时使用相同的缓存，确保与详细页面一致&#10;    val temperatureChartData = remember(currentHour) { &#10;        MockDataGenerator.generate24HourChartData(DataType.TEMPERATURE) &#10;    }&#10;    val humidityChartData = remember(currentHour) {&#10;        MockDataGenerator.generate24HourChartData(DataType.HUMIDITY)&#10;    }&#10;    val foodChartData = remember(currentHour) {&#10;        MockDataGenerator.generate24HourChartData(DataType.FOOD)&#10;    }&#10;    val waterChartData = remember(currentHour) {&#10;        MockDataGenerator.generate24HourChartData(DataType.WATER)&#10;    }&#10;&#10;    // 获取Context&#10;    val context = LocalContext.current&#10;&#10;    // 添加音频录制管理器&#10;    val audioRecordManager = remember { AudioRecordManager.getInstance() }&#10;    val isRecording by audioRecordManager.isRecording.collectAsStateWithLifecycle()&#10;    val volumeLevel by audioRecordManager.volumeLevel.collectAsStateWithLifecycle()&#10;    val hapticFeedback = LocalHapticFeedback.current&#10;&#10;    // 获取MQTT服务实例&#10;    val mqttService = remember { com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance() }&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        // 上半部分&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(280.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // 连接状态卡片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.4f)&#10;                    .padding(bottom = 12.dp)&#10;                    .clickable {&#10;                        // 点击连接状态卡片时尝试重新连接MQTT&#10;                        val mqttService = com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance()&#10;                        if (connectionStatus == &quot;MQTT连接&quot;) {&#10;                            // 如果已连接，先断开再重连&#10;                            mqttService.disconnect()&#10;                            CoroutineScope(Dispatchers.Main).launch {&#10;                                delay(1000) // 等待1秒&#10;                                mqttService.connect(context)&#10;                            }&#10;                        } else {&#10;                            // 如果未连接，直接尝试连接&#10;                            mqttService.connect(context)&#10;                        }&#10;                    },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(10.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // 状态指示点&#10;                    val indicatorColor = when (connectionStatus) {&#10;                        &quot;MQTT连接&quot; -&gt; Color(0xFF4CAF50)  // 绿色表示MQTT连接成功&#10;                        &quot;连接中...&quot; -&gt; Color(0xFFFF9800)  // 橙色表示连接中&#10;                        &quot;连接失败&quot;, &quot;连接断开&quot; -&gt; Color(0xFFF44336)  // 红色表示连接失败或断开&#10;                        null -&gt; Color(0xFF9E9E9E)  // 灰色表示未连接&#10;                        else -&gt; Color(0xFF9E9E9E)&#10;                    }&#10;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(indicatorColor)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(6.dp))&#10;                    Text(&#10;                        text = connectionStatus ?: &quot;未连接&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            // 设备图片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.cat),&#10;                        contentDescription = &quot;PetNest 智能猫窝&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 下半部分 - 设备状态&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&#10;                text = &quot;设备状态&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary,&#10;                modifier = Modifier.padding(bottom = 12.dp)&#10;            )&#10;&#10;            // 第一行：温度和湿度&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;温度&quot;,&#10;                    value = &quot;${deviceData.temperature.toInt()}°C&quot;,&#10;                    chartData = temperatureChartData,&#10;                    chartColor = Color.Red,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.TemperatureDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;湿度&quot;,&#10;                    value = &quot;${deviceData.humidity.toInt()}%&quot;,&#10;                    chartData = humidityChartData,&#10;                    chartColor = Color.Blue,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.HumidityDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第二行：食物量和水量&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;食物量&quot;,&#10;                    value = &quot;${deviceData.foodAmount.toInt()}g&quot;,&#10;                    chartData = foodChartData,&#10;                    chartColor = Color.Green,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.FoodDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;水量&quot;,&#10;                    value = &quot;${deviceData.waterAmount.toInt()}ml&quot;,&#10;                    chartData = waterChartData,&#10;                    chartColor = Color.Cyan,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.WaterDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第三行：通风状态和消毒状态&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                SwitchCard(&#10;                    label = &quot;通风开关&quot;,&#10;                    checked = deviceData.ventilationStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateVentilationStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendVentilationCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateVentilationStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;通风控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                SwitchCard(&#10;                    label = &quot;消毒开关&quot;,&#10;                    checked = deviceData.disinfectionStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateDisinfectionStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendDisinfectionCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateDisinfectionStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;消毒控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            // 第四行：加热状态&#10;            HeatingCard(&#10;                enabled = deviceData.heatingStatus,&#10;                onEnabledChange = { enabled -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateHeatingStatus(enabled)&#10;                    // 发送控制指令到设备&#10;                    mqttService.sendHeatingCommand(enabled) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateHeatingStatus(!enabled)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;加热控制指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                targetTemperature = deviceData.targetTemperature.toInt(),&#10;                onTemperatureChange = { temperature -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateTargetTemperature(temperature.toFloat())&#10;                    // 发送目标温度设置指令到设备&#10;                    mqttService.sendTargetTemperatureCommand(temperature) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateTargetTemperature(deviceData.targetTemperature)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;目标温度设置指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;            )&#10;&#10;            // 第五行：云端监控视频模块&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            CloudVideoMonitorCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                context = context,&#10;                hapticFeedback = hapticFeedback,&#10;                audioRecordManager = audioRecordManager,&#10;                isRecording = isRecording,&#10;                volumeLevel = volumeLevel&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnvironmentCard(&#10;    label: String,&#10;    value: String,&#10;    chartData: List&lt;ChartDataPoint&gt;,&#10;    chartColor: Color,&#10;    modifier: Modifier = Modifier,&#10;    onClick: () -&gt; Unit = {}&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .height(120.dp)&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp)&#10;        ) {&#10;            // 标题&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 16.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 数值&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            // 显示曲线图&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            MiniChart(&#10;                data = chartData,&#10;                lineColor = chartColor,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SwitchCard(&#10;    label: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(80.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (checked)&#10;                MaterialTheme.colorScheme.tertiaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)  // 关闭时为灰色状态&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (checked)&#10;                    MaterialTheme.colorScheme.onTertiaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f),  // 灰色文字&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Switch(&#10;                checked = checked,&#10;                onCheckedChange = onCheckedChange,&#10;                colors = SwitchDefaults.colors(&#10;                    checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                    checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    uncheckedThumbColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f),&#10;                    uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HeatingCard(&#10;    enabled: Boolean,&#10;    onEnabledChange: (Boolean) -&gt; Unit,&#10;    targetTemperature: Int,&#10;    onTemperatureChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(100.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // 第一行：标题和开关&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;加热开关：${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Switch(&#10;                    checked = enabled,&#10;                    onCheckedChange = onEnabledChange,&#10;                    modifier = Modifier.size(32.dp),&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        checkedTrackColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 第二行：温度控制&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &gt; 10) {&#10;                            onTemperatureChange(targetTemperature - 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Remove,&#10;                        contentDescription = &quot;降低温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;&#10;                Text(&#10;                    text = &quot;当前设定温度：${targetTemperature}°C&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &lt; 40) {&#10;                            onTemperatureChange(targetTemperature + 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Add,&#10;                        contentDescription = &quot;提高温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// 曲线图组件&#10;@Composable&#10;fun MiniChart(&#10;    data: List&lt;ChartDataPoint&gt;,&#10;    lineColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Canvas(modifier = modifier) {&#10;        if (data.isEmpty()) return@Canvas&#10;&#10;        val width = size.width&#10;        val height = size.height&#10;        val padding = 8.dp.toPx()&#10;        val textHeight = 10.dp.toPx()&#10;&#10;        // 计算数据范围&#10;        val minValue = data.minOf { it.value }&#10;        val maxValue = data.maxOf { it.value }&#10;        val valueRange = maxValue - minValue&#10;&#10;        // 为时间标签留出空间&#10;        val chartHeight = height - textHeight - 4.dp.toPx()&#10;&#10;        // 创建路径&#10;        val path = Path()&#10;&#10;        data.forEachIndexed { index, point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            if (index == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;&#10;        // 绘制曲线&#10;        drawPath(&#10;            path = path,&#10;            color = lineColor,&#10;            style = Stroke(&#10;                width = 1.5.dp.toPx(),&#10;                cap = StrokeCap.Round,&#10;                join = StrokeJoin.Round&#10;            )&#10;        )&#10;&#10;        // 绘制数据点&#10;        data.forEach { point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            drawCircle(&#10;                color = lineColor,&#10;                radius = 1.dp.toPx(),&#10;                center = Offset(x, y)&#10;            )&#10;        }&#10;&#10;        // 绘制时间轴文字标签&#10;        drawIntoCanvas { canvas -&gt;&#10;            val textPaint = android.graphics.Paint().apply {&#10;                color = Color.Gray.toArgb()&#10;                textSize = 8.sp.toPx()&#10;                isAntiAlias = true&#10;            }&#10;&#10;            // 绘制&quot;0:00&quot;标签&#10;            val startX = padding&#10;            val textY = height - 2.dp.toPx()&#10;            textPaint.textAlign = android.graphics.Paint.Align.LEFT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;0:00&quot;,&#10;                startX,&#10;                textY,&#10;                textPaint&#10;            )&#10;&#10;            // 绘制&quot;24:00&quot;标签&#10;            val endX = width - padding&#10;            textPaint.textAlign = android.graphics.Paint.Align.RIGHT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;24:00&quot;,&#10;                endX,&#10;                textY,&#10;                textPaint&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// 云端视频监控状态枚举&#10;enum class VideoStreamStatus {&#10;    LOADING,    // 加载中&#10;    PLAYING,    // 播放中&#10;    PAUSED,     // 暂停&#10;    ERROR,      // 错误&#10;    OFFLINE     // 离线&#10;}&#10;&#10;// 视频流数据类&#10;data class VideoStreamInfo(&#10;    val streamUrl: String,&#10;    val resolution: String,&#10;    val quality: String,&#10;    val isLive: Boolean&#10;)&#10;&#10;@Composable&#10;fun CloudVideoMonitorCard(&#10;    modifier: Modifier = Modifier,&#10;    context: android.content.Context,&#10;    hapticFeedback: androidx.compose.ui.hapticfeedback.HapticFeedback,&#10;    audioRecordManager: AudioRecordManager,&#10;    isRecording: Boolean,&#10;    volumeLevel: Float&#10;) {&#10;    var isFullscreen by remember { mutableStateOf(false) }&#10;&#10;    // FRP视频流URL&#10;    val streamUrl = remember {&#10;        // 示例FRP代理的RTMP/HTTP视频流地址&#10;        // 请根据你的实际FRP配置修改这个URL&#10;        &quot;http://your-frp-server:port/live/stream&quot;&#10;        // 或者RTSP流: &quot;rtsp://your-frp-server:port/live/stream&quot;&#10;        // 或者HLS流: &quot;http://your-frp-server:port/live/stream.m3u8&quot;&#10;    }&#10;&#10;    Column(modifier = modifier) {&#10;        // 实时监控视频标题&#10;        Text(&#10;            text = &quot;实时监控&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            modifier = Modifier.padding(bottom = 12.dp)&#10;        )&#10;&#10;        // 视频播放器组件&#10;        VideoStreamPlayer(&#10;            streamUrl = streamUrl,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            isFullscreen = isFullscreen,&#10;            onFullscreenToggle = { isFullscreen = !isFullscreen }&#10;        )&#10;&#10;        // 对讲功能控制区域&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;语音对讲&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // 对讲按钮&#10;                    IconButton(&#10;                        onClick = {&#10;                            hapticFeedback.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                            if (isRecording) {&#10;                                audioRecordManager.stopRecording()&#10;                            } else {&#10;                                if (audioRecordManager.hasRecordPermission(context)) {&#10;                                    audioRecordManager.startRecording(context)&#10;                                } else {&#10;                                    android.util.Log.e(&quot;DeviceScreen&quot;, &quot;没有录音权限&quot;)&#10;                                }&#10;                            }&#10;                        },&#10;                        colors = IconButtonDefaults.iconButtonColors(&#10;                            containerColor = if (isRecording) Color.Red.copy(alpha = 0.1f) else MaterialTheme.colorScheme.primaryContainer,&#10;                            contentColor = if (isRecording) Color.Red else MaterialTheme.colorScheme.primary&#10;                        )&#10;                    ) {&#10;                        Icon(&#10;                            if (isRecording) Icons.Default.MicOff else Icons.Default.Mic,&#10;                            contentDescription = if (isRecording) &quot;停止对讲&quot; else &quot;开始对讲&quot;&#10;                        )&#10;                    }&#10;&#10;                    // 音量指示器（录音时显示）&#10;                    if (isRecording) {&#10;                        val animatedVolumeLevel by animateFloatAsState(&#10;                            targetValue = volumeLevel,&#10;                            animationSpec = tween(durationMillis = 100)&#10;                        )&#10;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;音量:&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Canvas(&#10;                                modifier = Modifier&#10;                                    .width(40.dp)&#10;                                    .height(16.dp)&#10;                            ) {&#10;                                val barCount = 5&#10;                                val barWidth = size.width / barCount * 0.7f&#10;                                val activeBarCount = (animatedVolumeLevel * barCount).toInt()&#10;&#10;                                for (i in 0 until barCount) {&#10;                                    val barColor = if (i &lt; activeBarCount) {&#10;                                        Color.Green&#10;                                    } else {&#10;                                        Color.Gray.copy(alpha = 0.3f)&#10;                                    }&#10;                                    drawRect(&#10;                                        color = barColor,&#10;                                        topLeft = Offset(i * (size.width / barCount), size.height - (i + 1) * (size.height / barCount)),&#10;                                        size = androidx.compose.ui.geometry.Size(barWidth, (i + 1) * (size.height / barCount))&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DeviceScreenPreview() {&#10;    DeviceScreen()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.screens&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.MicOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.StrokeJoin&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import com.example.petnestiq.service.AudioRecordManager&#10;import com.example.petnestiq.R&#10;import com.example.petnestiq.navigation.NavigationItem&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.example.petnestiq.data.DataType&#10;import com.example.petnestiq.data.MockDataGenerator&#10;import com.example.petnestiq.data.ChartDataPoint&#10;import com.example.petnestiq.components.VideoStreamPlayer&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DeviceScreen(navController: NavController? = null) {&#10;    // 获取数据管理器实例&#10;    val deviceDataManager = remember { DeviceDataManager.getInstance() }&#10;    val deviceData by deviceDataManager.deviceData.collectAsStateWithLifecycle()&#10;    val connectionStatus by deviceDataManager.connectionStatus.collectAsStateWithLifecycle()&#10;&#10;    // 确保数据同步 - 页面加载时立即同步数据&#10;    LaunchedEffect(Unit) {&#10;        // 清除缓存确保获取最新数据&#10;        MockDataGenerator.clearCache()&#10;        deviceDataManager.updateWithCurrentValues()&#10;    }&#10;&#10;    // 每次重组时确保图表数据和当前值使用相同的时间点&#10;    val currentHour = remember { java.time.LocalDateTime.now().hour }&#10;    val currentMinute = remember { java.time.LocalDateTime.now().minute }&#10;    &#10;    // 生成图表数据时使用相同的缓存，确保与详细页面一致&#10;    val temperatureChartData = remember(currentHour) { &#10;        MockDataGenerator.generate24HourChartData(DataType.TEMPERATURE) &#10;    }&#10;    val humidityChartData = remember(currentHour) { &#10;        MockDataGenerator.generate24HourChartData(DataType.HUMIDITY) &#10;    }&#10;    val foodChartData = remember(currentHour) { &#10;        MockDataGenerator.generate24HourChartData(DataType.FOOD) &#10;    }&#10;    val waterChartData = remember(currentHour) { &#10;        MockDataGenerator.generate24HourChartData(DataType.WATER) &#10;    }&#10;&#10;    // 注意：显示的数值使用MQTT真实数据，图表使用模拟数据保持与详细页面一致&#10;&#10;    // 获取当前模拟数据值，确保与图表数据一致&#10;    val currentTemperature = remember(currentHour, currentMinute) {&#10;        MockDataGenerator.getCurrentValue(DataType.TEMPERATURE)&#10;    }&#10;    val currentHumidity = remember(currentHour, currentMinute) {&#10;        MockDataGenerator.getCurrentValue(DataType.HUMIDITY)&#10;    }&#10;    val currentFoodAmount = remember(currentHour, currentMinute) {&#10;        MockDataGenerator.getCurrentValue(DataType.FOOD)&#10;    }&#10;    val currentWaterAmount = remember(currentHour, currentMinute) {&#10;        MockDataGenerator.getCurrentValue(DataType.WATER)&#10;    }&#10;&#10;    // 获取Context&#10;    val context = LocalContext.current&#10;&#10;    // 添加音频录制管理器&#10;    val audioRecordManager = remember { AudioRecordManager.getInstance() }&#10;    val isRecording by audioRecordManager.isRecording.collectAsStateWithLifecycle()&#10;    val volumeLevel by audioRecordManager.volumeLevel.collectAsStateWithLifecycle()&#10;    val hapticFeedback = LocalHapticFeedback.current&#10;&#10;    // 获取MQTT服务实例&#10;    val mqttService = remember { com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance() }&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        // 上半部分&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(280.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // 连接状态卡片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.4f)&#10;                    .padding(bottom = 12.dp)&#10;                    .clickable {&#10;                        // 点击连接状态卡片时尝试重新连接MQTT&#10;                        val mqttService = com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance()&#10;                        if (connectionStatus == &quot;MQTT连接&quot;) {&#10;                            // 如果已连接，先断开再重连&#10;                            mqttService.disconnect()&#10;                            CoroutineScope(Dispatchers.Main).launch {&#10;                                delay(1000) // 等待1秒&#10;                                mqttService.connect(context)&#10;                            }&#10;                        } else {&#10;                            // 如果未连接，直接尝试连接&#10;                            mqttService.connect(context)&#10;                        }&#10;                    },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(10.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // 状态指示点&#10;                    val indicatorColor = when (connectionStatus) {&#10;                        &quot;MQTT连接&quot; -&gt; Color(0xFF4CAF50)  // 绿色表示MQTT连接成功&#10;                        &quot;连接中...&quot; -&gt; Color(0xFFFF9800)  // 橙色表示连接中&#10;                        &quot;连接失败&quot;, &quot;连接断开&quot; -&gt; Color(0xFFF44336)  // 红色表示连接失败或断开&#10;                        null -&gt; Color(0xFF9E9E9E)  // 灰色表示未连接&#10;                        else -&gt; Color(0xFF9E9E9E)&#10;                    }&#10;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(indicatorColor)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(6.dp))&#10;                    Text(&#10;                        text = connectionStatus ?: &quot;未连接&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            // 设备图片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.cat),&#10;                        contentDescription = &quot;PetNest 智能猫窝&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 下半部分 - 设备状态&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&#10;                text = &quot;设备状态&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary,&#10;                modifier = Modifier.padding(bottom = 12.dp)&#10;            )&#10;&#10;            // 第一行：温度和湿度&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;温度&quot;,&#10;                    value = &quot;${deviceData.temperature.toInt()}°C&quot;, // 使用MQTT真实数据&#10;                    chartData = temperatureChartData, // 使用模拟数据与详细页面保持一致&#10;                    chartColor = Color.Red,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.TemperatureDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;湿度&quot;,&#10;                    value = &quot;${deviceData.humidity.toInt()}%&quot;, // 使用MQTT真实数据&#10;                    chartData = humidityChartData, // 使用模拟数据与详细页面保持一致&#10;                    chartColor = Color.Blue,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.HumidityDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第二行：食物量和水量&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;食物量&quot;,&#10;                    value = &quot;${deviceData.foodAmount.toInt()}g&quot;, // 使用MQTT真实数据&#10;                    chartData = foodChartData, // 使用模拟数据与详细页面保持一致&#10;                    chartColor = Color.Green,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.FoodDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;水量&quot;,&#10;                    value = &quot;${deviceData.waterAmount.toInt()}ml&quot;, // 使用MQTT真实数据&#10;                    chartData = waterChartData, // 使用模拟数据与详细页面保持一致&#10;                    chartColor = Color.Cyan,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.WaterDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第三行：通风状态和消毒状态&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                SwitchCard(&#10;                    label = &quot;通风开关&quot;,&#10;                    checked = deviceData.ventilationStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateVentilationStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendVentilationCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateVentilationStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;通风控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                SwitchCard(&#10;                    label = &quot;消毒开关&quot;,&#10;                    checked = deviceData.disinfectionStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateDisinfectionStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendDisinfectionCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateDisinfectionStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;消毒控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            // 第四行：加热状态&#10;            HeatingCard(&#10;                enabled = deviceData.heatingStatus,&#10;                onEnabledChange = { enabled -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateHeatingStatus(enabled)&#10;                    // 发送控制指令到设备&#10;                    mqttService.sendHeatingCommand(enabled) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateHeatingStatus(!enabled)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;加热控制指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                targetTemperature = deviceData.targetTemperature.toInt(),&#10;                onTemperatureChange = { temperature -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateTargetTemperature(temperature.toFloat())&#10;                    // 发送目标温度设置指令到设备&#10;                    mqttService.sendTargetTemperatureCommand(temperature) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateTargetTemperature(deviceData.targetTemperature)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;目标温度设置指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;            )&#10;&#10;            // 第五行：云端监控视频模块&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            CloudVideoMonitorCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                context = context,&#10;                hapticFeedback = hapticFeedback,&#10;                audioRecordManager = audioRecordManager,&#10;                isRecording = isRecording,&#10;                volumeLevel = volumeLevel&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnvironmentCard(&#10;    label: String,&#10;    value: String,&#10;    chartData: List&lt;ChartDataPoint&gt;,&#10;    chartColor: Color,&#10;    modifier: Modifier = Modifier,&#10;    onClick: () -&gt; Unit = {}&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .height(120.dp)&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp)&#10;        ) {&#10;            // 标题&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 16.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 数值&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            // 显示曲线图&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            MiniChart(&#10;                data = chartData,&#10;                lineColor = chartColor,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SwitchCard(&#10;    label: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(80.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (checked)&#10;                MaterialTheme.colorScheme.tertiaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)  // 关闭时为灰色状态&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (checked)&#10;                    MaterialTheme.colorScheme.onTertiaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f),  // 灰色文字&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Switch(&#10;                checked = checked,&#10;                onCheckedChange = onCheckedChange,&#10;                colors = SwitchDefaults.colors(&#10;                    checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                    checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    uncheckedThumbColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f),&#10;                    uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HeatingCard(&#10;    enabled: Boolean,&#10;    onEnabledChange: (Boolean) -&gt; Unit,&#10;    targetTemperature: Int,&#10;    onTemperatureChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(100.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // 第一行：标题和开关&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;加热开关：${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Switch(&#10;                    checked = enabled,&#10;                    onCheckedChange = onEnabledChange,&#10;                    modifier = Modifier.size(32.dp),&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        checkedTrackColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 第二行：温度控制&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &gt; 10) {&#10;                            onTemperatureChange(targetTemperature - 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Remove,&#10;                        contentDescription = &quot;降低温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;&#10;                Text(&#10;                    text = &quot;当前设定温度：${targetTemperature}°C&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &lt; 40) {&#10;                            onTemperatureChange(targetTemperature + 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Add,&#10;                        contentDescription = &quot;提高温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// 曲线图组件&#10;@Composable&#10;fun MiniChart(&#10;    data: List&lt;ChartDataPoint&gt;,&#10;    lineColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Canvas(modifier = modifier) {&#10;        if (data.isEmpty()) return@Canvas&#10;&#10;        val width = size.width&#10;        val height = size.height&#10;        val padding = 8.dp.toPx()&#10;        val textHeight = 10.dp.toPx()&#10;&#10;        // 计算数据范围&#10;        val minValue = data.minOf { it.value }&#10;        val maxValue = data.maxOf { it.value }&#10;        val valueRange = maxValue - minValue&#10;&#10;        // 为时间标签留出空间&#10;        val chartHeight = height - textHeight - 4.dp.toPx()&#10;&#10;        // 创建路径&#10;        val path = Path()&#10;&#10;        data.forEachIndexed { index, point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            if (index == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;&#10;        // 绘制曲线&#10;        drawPath(&#10;            path = path,&#10;            color = lineColor,&#10;            style = Stroke(&#10;                width = 1.5.dp.toPx(),&#10;                cap = StrokeCap.Round,&#10;                join = StrokeJoin.Round&#10;            )&#10;        )&#10;&#10;        // 绘制数据点&#10;        data.forEach { point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            drawCircle(&#10;                color = lineColor,&#10;                radius = 1.dp.toPx(),&#10;                center = Offset(x, y)&#10;            )&#10;        }&#10;&#10;        // 绘制时间轴文字标签&#10;        drawIntoCanvas { canvas -&gt;&#10;            val textPaint = android.graphics.Paint().apply {&#10;                color = Color.Gray.toArgb()&#10;                textSize = 8.sp.toPx()&#10;                isAntiAlias = true&#10;            }&#10;&#10;            // 绘制&quot;0:00&quot;标签&#10;            val startX = padding&#10;            val textY = height - 2.dp.toPx()&#10;            textPaint.textAlign = android.graphics.Paint.Align.LEFT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;0:00&quot;,&#10;                startX,&#10;                textY,&#10;                textPaint&#10;            )&#10;&#10;            // 绘制&quot;24:00&quot;标签&#10;            val endX = width - padding&#10;            textPaint.textAlign = android.graphics.Paint.Align.RIGHT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;24:00&quot;,&#10;                endX,&#10;                textY,&#10;                textPaint&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// 云端视频监控状态枚举&#10;enum class VideoStreamStatus {&#10;    LOADING,    // 加载中&#10;    PLAYING,    // 播放中&#10;    PAUSED,     // 暂停&#10;    ERROR,      // 错误&#10;    OFFLINE     // 离线&#10;}&#10;&#10;// 视频流数据类&#10;data class VideoStreamInfo(&#10;    val streamUrl: String,&#10;    val resolution: String,&#10;    val quality: String,&#10;    val isLive: Boolean&#10;)&#10;&#10;@Composable&#10;fun CloudVideoMonitorCard(&#10;    modifier: Modifier = Modifier,&#10;    context: android.content.Context,&#10;    hapticFeedback: androidx.compose.ui.hapticfeedback.HapticFeedback,&#10;    audioRecordManager: AudioRecordManager,&#10;    isRecording: Boolean,&#10;    volumeLevel: Float&#10;) {&#10;    var isFullscreen by remember { mutableStateOf(false) }&#10;&#10;    // FRP视频流URL&#10;    val streamUrl = remember {&#10;        // 示例FRP代理的RTMP/HTTP视频流地址&#10;        // 请根据你的实际FRP配置修改这个URL&#10;        &quot;http://your-frp-server:port/live/stream&quot;&#10;        // 或者RTSP流: &quot;rtsp://your-frp-server:port/live/stream&quot;&#10;        // 或者HLS流: &quot;http://your-frp-server:port/live/stream.m3u8&quot;&#10;    }&#10;&#10;    Column(modifier = modifier) {&#10;        // 实时监控视频标题&#10;        Text(&#10;            text = &quot;实时监控&quot;,&#10;            style = MaterialTheme.typography.headlineSmall,&#10;            fontWeight = FontWeight.Bold,&#10;            color = MaterialTheme.colorScheme.primary,&#10;            modifier = Modifier.padding(bottom = 12.dp)&#10;        )&#10;&#10;        // 视频播放器组件&#10;        VideoStreamPlayer(&#10;            streamUrl = streamUrl,&#10;            modifier = Modifier.fillMaxWidth(),&#10;            isFullscreen = isFullscreen,&#10;            onFullscreenToggle = { isFullscreen = !isFullscreen }&#10;        )&#10;&#10;        // 对讲功能控制区域&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(12.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;语音对讲&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // 对讲按钮&#10;                    IconButton(&#10;                        onClick = {&#10;                            hapticFeedback.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                            if (isRecording) {&#10;                                audioRecordManager.stopRecording()&#10;                            } else {&#10;                                if (audioRecordManager.hasRecordPermission(context)) {&#10;                                    audioRecordManager.startRecording(context)&#10;                                } else {&#10;                                    android.util.Log.e(&quot;DeviceScreen&quot;, &quot;没有录音权限&quot;)&#10;                                }&#10;                            }&#10;                        },&#10;                        colors = IconButtonDefaults.iconButtonColors(&#10;                            containerColor = if (isRecording) Color.Red.copy(alpha = 0.1f) else MaterialTheme.colorScheme.primaryContainer,&#10;                            contentColor = if (isRecording) Color.Red else MaterialTheme.colorScheme.primary&#10;                        )&#10;                    ) {&#10;                        Icon(&#10;                            if (isRecording) Icons.Default.MicOff else Icons.Default.Mic,&#10;                            contentDescription = if (isRecording) &quot;停止对讲&quot; else &quot;开始对讲&quot;&#10;                        )&#10;                    }&#10;&#10;                    // 音量指示器（录音时显示）&#10;                    if (isRecording) {&#10;                        val animatedVolumeLevel by animateFloatAsState(&#10;                            targetValue = volumeLevel,&#10;                            animationSpec = tween(durationMillis = 100)&#10;                        )&#10;&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;音量:&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Canvas(&#10;                                modifier = Modifier&#10;                                    .width(40.dp)&#10;                                    .height(16.dp)&#10;                            ) {&#10;                                val barCount = 5&#10;                                val barWidth = size.width / barCount * 0.7f&#10;                                val activeBarCount = (animatedVolumeLevel * barCount).toInt()&#10;&#10;                                for (i in 0 until barCount) {&#10;                                    val barColor = if (i &lt; activeBarCount) {&#10;                                        Color.Green&#10;                                    } else {&#10;                                        Color.Gray.copy(alpha = 0.3f)&#10;                                    }&#10;                                    drawRect(&#10;                                        color = barColor,&#10;                                        topLeft = Offset(i * (size.width / barCount), size.height - (i + 1) * (size.height / barCount)),&#10;                                        size = androidx.compose.ui.geometry.Size(barWidth, (i + 1) * (size.height / barCount))&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DeviceScreenPreview() {&#10;    DeviceScreen()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;PetNest IQ&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;喵星人の智能窝&lt;/string&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>