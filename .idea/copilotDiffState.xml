<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- 通知权限 --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#10;&#10;    &lt;!-- 网络权限 --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.PetNestIQ&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.PetNestIQ&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- 通知权限 --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;!-- 网络权限 --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;!-- 录音权限 - 用于对讲功能 --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.PetNestIQ&quot;&#13;&#10;        tools:targetApi=&quot;31&quot;&gt;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:label=&quot;@string/app_name&quot;&#13;&#10;            android:theme=&quot;@style/Theme.PetNestIQ&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/screens/DeviceScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/screens/DeviceScreen.kt" />
              <option name="originalContent" value="package com.example.petnestiq.screens&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.MicOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.StrokeJoin&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import com.example.petnestiq.service.AudioRecordManager&#10;import com.example.petnestiq.R&#10;import com.example.petnestiq.navigation.NavigationItem&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.example.petnestiq.data.DataType&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;// 数据类定义&#10;data class ChartDataPoint(&#10;    val hour: Int,  // 0-24小时&#10;    val value: Float&#10;)&#10;&#10;// 生成模拟数据的函数&#10;fun generateTemperatureData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟温度变化&#10;        val baseTemp = 20f + 8f * sin((hour - 6) * Math.PI / 12).toFloat() + Random.nextFloat() * 3f&#10;        ChartDataPoint(hour, baseTemp.coerceIn(15f, 35f))&#10;    }&#10;}&#10;&#10;fun generateHumidityData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟湿度变化：相对稳定，有小幅波动&#10;        val baseHumidity = 60f + 15f * sin((hour - 3) * Math.PI / 12).toFloat() + Random.nextFloat() * 10f&#10;        ChartDataPoint(hour, baseHumidity.coerceIn(40f, 85f))&#10;    }&#10;}&#10;&#10;fun generateFoodData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟食物量变化：逐渐减少，定时补充&#10;        val baseFood = if (hour % 8 == 0) 500f else 500f - (hour % 8) * 50f + Random.nextFloat() * 20f&#10;        ChartDataPoint(hour, baseFood.coerceIn(0f, 500f))&#10;    }&#10;}&#10;&#10;fun generateWaterData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟水量变化：逐渐减少，定时补充&#10;        val baseWater = if (hour % 6 == 0) 500f else 500f - (hour % 6) * 70f + Random.nextFloat() * 30f&#10;        ChartDataPoint(hour, baseWater.coerceIn(0f, 500f))&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DeviceScreen(navController: NavController? = null) {&#10;    // 获取数据管理器实例&#10;    val deviceDataManager = remember { DeviceDataManager.getInstance() }&#10;    val deviceData by deviceDataManager.deviceData.collectAsStateWithLifecycle()&#10;    val connectionStatus by deviceDataManager.connectionStatus.collectAsStateWithLifecycle()&#10;&#10;    // 获取Context&#10;    val context = LocalContext.current&#10;&#10;    // 添加音频录制管理器&#10;    val audioRecordManager = remember { AudioRecordManager.getInstance() }&#10;    val isRecording by audioRecordManager.isRecording.collectAsStateWithLifecycle()&#10;    val volumeLevel by audioRecordManager.volumeLevel.collectAsStateWithLifecycle()&#10;    val hapticFeedback = LocalHapticFeedback.current&#10;&#10;    // 获取MQTT服务实例&#10;    val mqttService = remember { com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance() }&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        // 上半部分&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(280.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // 连接状态卡片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.4f)&#10;                    .padding(bottom = 12.dp)&#10;                    .clickable {&#10;                        // 点击连接状态卡片时尝试重新连接MQTT&#10;                        val mqttService = com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance()&#10;                        if (connectionStatus == &quot;MQTT连接&quot;) {&#10;                            // 如果已连接，先断开再重连&#10;                            mqttService.disconnect()&#10;                            CoroutineScope(Dispatchers.Main).launch {&#10;                                delay(1000) // 等待1秒&#10;                                mqttService.connect(context)&#10;                            }&#10;                        } else {&#10;                            // 如果未连接，直接尝试连接&#10;                            mqttService.connect(context)&#10;                        }&#10;                    },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(10.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // 状态指示点&#10;                    val indicatorColor = when (connectionStatus) {&#10;                        &quot;MQTT连接&quot; -&gt; Color(0xFF4CAF50)  // 绿色表示MQTT连接成功&#10;                        &quot;连接中...&quot; -&gt; Color(0xFFFF9800)  // 橙色表示连接中&#10;                        &quot;连接失败&quot;, &quot;连接断开&quot; -&gt; Color(0xFFF44336)  // 红色表示连接失败或断开&#10;                        null -&gt; Color(0xFF9E9E9E)  // 灰色表示未连接&#10;                        else -&gt; Color(0xFF9E9E9E)&#10;                    }&#10;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(indicatorColor)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(6.dp))&#10;                    Text(&#10;                        text = connectionStatus ?: &quot;未连接&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            // 设备图片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.cat),&#10;                        contentDescription = &quot;PetNest 智能猫窝&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 下半部分 - 设备状态&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&#10;                text = &quot;设备状态&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary,&#10;                modifier = Modifier.padding(bottom = 12.dp)&#10;            )&#10;&#10;            // 第一行：温度和湿度&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;温度&quot;,&#10;                    value = &quot;${deviceData.temperature.toInt()}°C&quot;,&#10;                    chartData = generateTemperatureData(),&#10;                    chartColor = Color.Red,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.TemperatureDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;湿度&quot;,&#10;                    value = &quot;${deviceData.humidity.toInt()}%&quot;,&#10;                    chartData = generateHumidityData(),&#10;                    chartColor = Color.Blue,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.HumidityDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第二行：食物量和水量&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;食物量&quot;,&#10;                    value = &quot;${deviceData.foodAmount.toInt()}g&quot;,&#10;                    chartData = generateFoodData(),&#10;                    chartColor = Color.Green,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.FoodDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;水量&quot;,&#10;                    value = &quot;${deviceData.waterAmount.toInt()}ml&quot;,&#10;                    chartData = generateWaterData(),&#10;                    chartColor = Color.Cyan,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.WaterDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第三行：通风状态和消毒状态&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                SwitchCard(&#10;                    label = &quot;通风开关&quot;,&#10;                    checked = deviceData.ventilationStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateVentilationStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendVentilationCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateVentilationStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;通风控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                SwitchCard(&#10;                    label = &quot;消毒开关&quot;,&#10;                    checked = deviceData.disinfectionStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateDisinfectionStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendDisinfectionCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateDisinfectionStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;消毒控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            // 第四行：加热状态&#10;            HeatingCard(&#10;                enabled = deviceData.heatingStatus,&#10;                onEnabledChange = { enabled -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateHeatingStatus(enabled)&#10;                    // 发送控制指令到设备&#10;                    mqttService.sendHeatingCommand(enabled) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateHeatingStatus(!enabled)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;加热控制指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                targetTemperature = deviceData.targetTemperature.toInt(),&#10;                onTemperatureChange = { temperature -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateTargetTemperature(temperature.toFloat())&#10;                    // 发送目标温度设置指令到设备&#10;                    mqttService.sendTargetTemperatureCommand(temperature) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateTargetTemperature(deviceData.targetTemperature)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;目标温度设置指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;            )&#10;&#10;            // 第五行：云端监控视频模块&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            CloudVideoMonitorCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnvironmentCard(&#10;    label: String,&#10;    value: String,&#10;    chartData: List&lt;ChartDataPoint&gt;,&#10;    chartColor: Color,&#10;    modifier: Modifier = Modifier,&#10;    onClick: () -&gt; Unit = {}&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .height(120.dp)&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp)&#10;        ) {&#10;            // 标题&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 16.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 数值&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            // 显示曲线图&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            MiniChart(&#10;                data = chartData,&#10;                lineColor = chartColor,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SwitchCard(&#10;    label: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(80.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (checked)&#10;                MaterialTheme.colorScheme.tertiaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)  // 关闭时为灰色状态&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (checked)&#10;                    MaterialTheme.colorScheme.onTertiaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f),  // 灰色文字&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Switch(&#10;                checked = checked,&#10;                onCheckedChange = onCheckedChange,&#10;                colors = SwitchDefaults.colors(&#10;                    checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                    checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    uncheckedThumbColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f),&#10;                    uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HeatingCard(&#10;    enabled: Boolean,&#10;    onEnabledChange: (Boolean) -&gt; Unit,&#10;    targetTemperature: Int,&#10;    onTemperatureChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(100.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // 第一行：标题和开关&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;加热开关：${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Switch(&#10;                    checked = enabled,&#10;                    onCheckedChange = onEnabledChange,&#10;                    modifier = Modifier.size(32.dp),&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        checkedTrackColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 第二行：温度控制&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &gt; 10) {&#10;                            onTemperatureChange(targetTemperature - 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Remove,&#10;                        contentDescription = &quot;降低温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;&#10;                Text(&#10;                    text = &quot;当前设定温度：${targetTemperature}°C&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &lt; 40) {&#10;                            onTemperatureChange(targetTemperature + 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Add,&#10;                        contentDescription = &quot;提高温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// 曲线图组件&#10;@Composable&#10;fun MiniChart(&#10;    data: List&lt;ChartDataPoint&gt;,&#10;    lineColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Canvas(modifier = modifier) {&#10;        if (data.isEmpty()) return@Canvas&#10;&#10;        val width = size.width&#10;        val height = size.height&#10;        val padding = 8.dp.toPx()&#10;        val textHeight = 10.dp.toPx()&#10;&#10;        // 计算数据范围&#10;        val minValue = data.minOf { it.value }&#10;        val maxValue = data.maxOf { it.value }&#10;        val valueRange = maxValue - minValue&#10;&#10;        // 为时间标签留出空间&#10;        val chartHeight = height - textHeight - 4.dp.toPx()&#10;&#10;        // 创建路径&#10;        val path = Path()&#10;&#10;        data.forEachIndexed { index, point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            if (index == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;&#10;        // 绘制曲线&#10;        drawPath(&#10;            path = path,&#10;            color = lineColor,&#10;            style = Stroke(&#10;                width = 1.5.dp.toPx(),&#10;                cap = StrokeCap.Round,&#10;                join = StrokeJoin.Round&#10;            )&#10;        )&#10;&#10;        // 绘制数据点&#10;        data.forEach { point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            drawCircle(&#10;                color = lineColor,&#10;                radius = 1.dp.toPx(),&#10;                center = Offset(x, y)&#10;            )&#10;        }&#10;&#10;        // 绘制时间轴文字标签&#10;        drawIntoCanvas { canvas -&gt;&#10;            val textPaint = android.graphics.Paint().apply {&#10;                color = Color.Gray.toArgb()&#10;                textSize = 8.sp.toPx()&#10;                isAntiAlias = true&#10;            }&#10;&#10;            // 绘制&quot;0:00&quot;标签&#10;            val startX = padding&#10;            val textY = height - 2.dp.toPx()&#10;            textPaint.textAlign = android.graphics.Paint.Align.LEFT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;0:00&quot;,&#10;                startX,&#10;                textY,&#10;                textPaint&#10;            )&#10;&#10;            // 绘制&quot;24:00&quot;标签&#10;            val endX = width - padding&#10;            textPaint.textAlign = android.graphics.Paint.Align.RIGHT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;24:00&quot;,&#10;                endX,&#10;                textY,&#10;                textPaint&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// 云端视频监控状态枚举&#10;enum class VideoStreamStatus {&#10;    LOADING,    // 加载中&#10;    PLAYING,    // 播放中&#10;    PAUSED,     // 暂停&#10;    ERROR,      // 错误&#10;    OFFLINE     // 离线&#10;}&#10;&#10;// 视频流数据类&#10;data class VideoStreamInfo(&#10;    val streamUrl: String,&#10;    val resolution: String,&#10;    val quality: String,&#10;    val isLive: Boolean&#10;)&#10;&#10;@Composable&#10;fun CloudVideoMonitorCard(&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var videoStatus by remember { mutableStateOf(VideoStreamStatus.OFFLINE) }&#10;    var isPlaying by remember { mutableStateOf(false) }&#10;    var showSettings by remember { mutableStateOf(false) }&#10;&#10;    Card(&#10;        modifier = modifier.height(300.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // 标题栏&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;云端监控&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    // 实时状态指示器&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(&#10;                                when (videoStatus) {&#10;                                    VideoStreamStatus.PLAYING -&gt; Color(0xFF4CAF50)&#10;                                    VideoStreamStatus.LOADING -&gt; Color(0xFFFF9800)&#10;                                    VideoStreamStatus.ERROR -&gt; Color(0xFFF44336)&#10;                                    else -&gt; Color.Gray&#10;                                }&#10;                            )&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;&#10;                    Text(&#10;                        text = when (videoStatus) {&#10;                            VideoStreamStatus.PLAYING -&gt; &quot;直播中&quot;&#10;                            VideoStreamStatus.LOADING -&gt; &quot;连接中&quot;&#10;                            VideoStreamStatus.PAUSED -&gt; &quot;已暂停&quot;&#10;                            VideoStreamStatus.ERROR -&gt; &quot;连接失败&quot;&#10;                            VideoStreamStatus.OFFLINE -&gt; &quot;离线&quot;&#10;                        },&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;&#10;                // 设置按钮&#10;                IconButton(&#10;                    onClick = { showSettings = !showSettings },&#10;                    modifier = Modifier.size(24.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Settings,&#10;                        contentDescription = &quot;设置&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.size(18.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // 视频播放区域&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                shape = RoundedCornerShape(8.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = Color.Black&#10;                )&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    when (videoStatus) {&#10;                        VideoStreamStatus.OFFLINE, VideoStreamStatus.ERROR -&gt; {&#10;                            Column(&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Default.Refresh,&#10;                                    contentDescription = &quot;重新连接&quot;,&#10;                                    tint = Color.White.copy(alpha = 0.6f),&#10;                                    modifier = Modifier.size(32.dp)&#10;                                )&#10;                                Spacer(modifier = Modifier.height(4.dp))&#10;                                Text(&#10;                                    text = if (videoStatus == VideoStreamStatus.ERROR) &quot;连接失败&quot; else &quot;点击连接&quot;,&#10;                                    color = Color.White.copy(alpha = 0.6f),&#10;                                    style = MaterialTheme.typography.bodySmall&#10;                                )&#10;                            }&#10;                        }&#10;                        VideoStreamStatus.LOADING -&gt; {&#10;                            Column(&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                CircularProgressIndicator(&#10;                                    color = Color.White,&#10;                                    modifier = Modifier.size(24.dp),&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Text(&#10;                                    text = &quot;正在连接...&quot;,&#10;                                    color = Color.White.copy(alpha = 0.8f),&#10;                                    style = MaterialTheme.typography.bodySmall&#10;                                )&#10;                            }&#10;                        }&#10;                        VideoStreamStatus.PLAYING, VideoStreamStatus.PAUSED -&gt; {&#10;                            // TODO: 这里将来集成实际的视频播放器&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .background(Color.Black)&#10;                                    .clickable {&#10;                                        isPlaying = !isPlaying&#10;                                        videoStatus = if (isPlaying) VideoStreamStatus.PLAYING else VideoStreamStatus.PAUSED&#10;                                    },&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                if (videoStatus == VideoStreamStatus.PAUSED) {&#10;                                    Icon(&#10;                                        Icons.Default.PlayArrow,&#10;                                        contentDescription = &quot;播放&quot;,&#10;                                        tint = Color.White.copy(alpha = 0.8f),&#10;                                        modifier = Modifier.size(48.dp)&#10;                                    )&#10;                                }&#10;&#10;                                // 模拟视频内容（占位符）&#10;                                Text(&#10;                                    text = &quot;实时监控画面&quot;,&#10;                                    color = Color.White.copy(alpha = 0.5f),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    modifier = Modifier.align(Alignment.TopStart).padding(8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // 控制按钮区域&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // 播放/暂停按钮&#10;                IconButton(&#10;                    onClick = {&#10;                        when (videoStatus) {&#10;                            VideoStreamStatus.OFFLINE, VideoStreamStatus.ERROR -&gt; {&#10;                                videoStatus = VideoStreamStatus.LOADING&#10;                                // TODO: 启动视频流连接&#10;                                // 模拟连接延迟&#10;                                kotlin.concurrent.thread {&#10;                                    Thread.sleep(2000)&#10;                                    videoStatus = VideoStreamStatus.PLAYING&#10;                                    isPlaying = true&#10;                                }&#10;                            }&#10;                            VideoStreamStatus.PLAYING -&gt; {&#10;                                videoStatus = VideoStreamStatus.PAUSED&#10;                                isPlaying = false&#10;                            }&#10;                            VideoStreamStatus.PAUSED -&gt; {&#10;                                videoStatus = VideoStreamStatus.PLAYING&#10;                                isPlaying = true&#10;                            }&#10;                            else -&gt; {}&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        when (videoStatus) {&#10;                            VideoStreamStatus.PLAYING -&gt; Icons.Default.Pause&#10;                            else -&gt; Icons.Default.PlayArrow&#10;                        },&#10;                        contentDescription = if (isPlaying) &quot;暂停&quot; else &quot;播放&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                // 刷新按钮&#10;                IconButton(&#10;                    onClick = {&#10;                        videoStatus = VideoStreamStatus.LOADING&#10;                        // TODO: 重新连接视频流&#10;                        kotlin.concurrent.thread {&#10;                            Thread.sleep(1500)&#10;                            videoStatus = VideoStreamStatus.PLAYING&#10;                            isPlaying = true&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Refresh,&#10;                        contentDescription = &quot;刷新&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                // 对讲功能按钮&#10;                IconButton(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                        if (isRecording) {&#10;                            // 如果当前正在录音，则停止录音&#10;                            audioRecordManager.stopRecording()&#10;                        } else {&#10;                            // 启动录音&#10;                            if (audioRecordManager.hasRecordPermission(context)) {&#10;                                audioRecordManager.startRecording(context)&#10;                            } else {&#10;                                android.util.Log.e(&quot;DeviceScreen&quot;, &quot;没有录音权限&quot;)&#10;                                // TODO: 请求录音权限&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        if (isRecording) Icons.Default.MicOff else Icons.Default.Mic,&#10;                        contentDescription = if (isRecording) &quot;停止对讲&quot; else &quot;开始对讲&quot;,&#10;                        tint = if (isRecording) Color.Red else MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                // 录音音量指示器（仅在录音时显示）&#10;                if (isRecording) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(40.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color.Red.copy(alpha = 0.1f)),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        // 音量级别指示器&#10;                        val animatedVolumeLevel by animateFloatAsState(&#10;                            targetValue = volumeLevel,&#10;                            animationSpec = tween(durationMillis = 100)&#10;                        )&#10;&#10;                        Canvas(modifier = Modifier.size(24.dp)) {&#10;                            drawCircle(&#10;                                color = Color.Red,&#10;                                radius = size.minDimension / 4 * (0.3f + animatedVolumeLevel * 0.7f)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 视频信息显示&#10;            if (videoStatus == VideoStreamStatus.PLAYING) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = &quot;1080P&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)&#10;                    )&#10;                    Text(&#10;                        text = &quot;延迟: 200ms&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DeviceScreenPreview() {&#10;    DeviceScreen()&#10;}" />
              <option name="updatedContent" value="package com.example.petnestiq.screens&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Add&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material.icons.filled.Pause&#10;import androidx.compose.material.icons.filled.Refresh&#10;import androidx.compose.material.icons.filled.Remove&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.MicOff&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.Path&#10;import androidx.compose.ui.graphics.StrokeCap&#10;import androidx.compose.ui.graphics.StrokeJoin&#10;import androidx.compose.ui.graphics.drawscope.Stroke&#10;import androidx.compose.ui.graphics.drawscope.drawIntoCanvas&#10;import androidx.compose.ui.graphics.nativeCanvas&#10;import androidx.compose.ui.graphics.toArgb&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import com.example.petnestiq.service.AudioRecordManager&#10;import com.example.petnestiq.R&#10;import com.example.petnestiq.navigation.NavigationItem&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.example.petnestiq.data.DataType&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.sin&#10;import kotlin.random.Random&#10;&#10;// 数据类定义&#10;data class ChartDataPoint(&#10;    val hour: Int,  // 0-24小时&#10;    val value: Float&#10;)&#10;&#10;// 生成模拟数据的函数&#10;fun generateTemperatureData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟温度变化&#10;        val baseTemp = 20f + 8f * sin((hour - 6) * Math.PI / 12).toFloat() + Random.nextFloat() * 3f&#10;        ChartDataPoint(hour, baseTemp.coerceIn(15f, 35f))&#10;    }&#10;}&#10;&#10;fun generateHumidityData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟湿度变化：相对稳定，有小幅波动&#10;        val baseHumidity = 60f + 15f * sin((hour - 3) * Math.PI / 12).toFloat() + Random.nextFloat() * 10f&#10;        ChartDataPoint(hour, baseHumidity.coerceIn(40f, 85f))&#10;    }&#10;}&#10;&#10;fun generateFoodData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟食物量变化：逐渐减少，定时补充&#10;        val baseFood = if (hour % 8 == 0) 500f else 500f - (hour % 8) * 50f + Random.nextFloat() * 20f&#10;        ChartDataPoint(hour, baseFood.coerceIn(0f, 500f))&#10;    }&#10;}&#10;&#10;fun generateWaterData(): List&lt;ChartDataPoint&gt; {&#10;    return (0..23).map { hour -&gt;&#10;        // 模拟水量变化：逐渐减少，定时补充&#10;        val baseWater = if (hour % 6 == 0) 500f else 500f - (hour % 6) * 70f + Random.nextFloat() * 30f&#10;        ChartDataPoint(hour, baseWater.coerceIn(0f, 500f))&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DeviceScreen(navController: NavController? = null) {&#10;    // 获取数据管理器实例&#10;    val deviceDataManager = remember { DeviceDataManager.getInstance() }&#10;    val deviceData by deviceDataManager.deviceData.collectAsStateWithLifecycle()&#10;    val connectionStatus by deviceDataManager.connectionStatus.collectAsStateWithLifecycle()&#10;&#10;    // 获取Context&#10;    val context = LocalContext.current&#10;&#10;    // 添加音频录制管理器&#10;    val audioRecordManager = remember { AudioRecordManager.getInstance() }&#10;    val isRecording by audioRecordManager.isRecording.collectAsStateWithLifecycle()&#10;    val volumeLevel by audioRecordManager.volumeLevel.collectAsStateWithLifecycle()&#10;    val hapticFeedback = LocalHapticFeedback.current&#10;&#10;    // 获取MQTT服务实例&#10;    val mqttService = remember { com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance() }&#10;&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        // 上半部分&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(280.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // 连接状态卡片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth(0.4f)&#10;                    .padding(bottom = 12.dp)&#10;                    .clickable {&#10;                        // 点击连接状态卡片时尝试重新连接MQTT&#10;                        val mqttService = com.example.petnestiq.service.HuaweiIoTDAMqttService.getInstance()&#10;                        if (connectionStatus == &quot;MQTT连接&quot;) {&#10;                            // 如果已连接，先断开再重连&#10;                            mqttService.disconnect()&#10;                            CoroutineScope(Dispatchers.Main).launch {&#10;                                delay(1000) // 等待1秒&#10;                                mqttService.connect(context)&#10;                            }&#10;                        } else {&#10;                            // 如果未连接，直接尝试连接&#10;                            mqttService.connect(context)&#10;                        }&#10;                    },&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(10.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // 状态指示点&#10;                    val indicatorColor = when (connectionStatus) {&#10;                        &quot;MQTT连接&quot; -&gt; Color(0xFF4CAF50)  // 绿色表示MQTT连接成功&#10;                        &quot;连接中...&quot; -&gt; Color(0xFFFF9800)  // 橙色表示连接中&#10;                        &quot;连接失败&quot;, &quot;连接断开&quot; -&gt; Color(0xFFF44336)  // 红色表示连接失败或断开&#10;                        null -&gt; Color(0xFF9E9E9E)  // 灰色表示未连接&#10;                        else -&gt; Color(0xFF9E9E9E)&#10;                    }&#10;&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(indicatorColor)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(6.dp))&#10;                    Text(&#10;                        text = connectionStatus ?: &quot;未连接&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;&#10;            // 设备图片&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                shape = RoundedCornerShape(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface&#10;                ),&#10;                elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.cat),&#10;                        contentDescription = &quot;PetNest 智能猫窝&quot;,&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentScale = ContentScale.Fit&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // 下半部分 - 设备状态&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&#10;                text = &quot;设备状态&quot;,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary,&#10;                modifier = Modifier.padding(bottom = 12.dp)&#10;            )&#10;&#10;            // 第一行：温度和湿度&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;温度&quot;,&#10;                    value = &quot;${deviceData.temperature.toInt()}°C&quot;,&#10;                    chartData = generateTemperatureData(),&#10;                    chartColor = Color.Red,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.TemperatureDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;湿度&quot;,&#10;                    value = &quot;${deviceData.humidity.toInt()}%&quot;,&#10;                    chartData = generateHumidityData(),&#10;                    chartColor = Color.Blue,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.HumidityDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第二行：食物量和水量&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                EnvironmentCard(&#10;                    label = &quot;食物量&quot;,&#10;                    value = &quot;${deviceData.foodAmount.toInt()}g&quot;,&#10;                    chartData = generateFoodData(),&#10;                    chartColor = Color.Green,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.FoodDetail.route) }&#10;                )&#10;                EnvironmentCard(&#10;                    label = &quot;水量&quot;,&#10;                    value = &quot;${deviceData.waterAmount.toInt()}ml&quot;,&#10;                    chartData = generateWaterData(),&#10;                    chartColor = Color.Cyan,&#10;                    modifier = Modifier.weight(1f),&#10;                    onClick = { navController?.navigate(NavigationItem.WaterDetail.route) }&#10;                )&#10;            }&#10;&#10;            // 第三行：通风状态和消毒状态&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 8.dp),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                SwitchCard(&#10;                    label = &quot;通风开关&quot;,&#10;                    checked = deviceData.ventilationStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateVentilationStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendVentilationCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateVentilationStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;通风控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                SwitchCard(&#10;                    label = &quot;消毒开关&quot;,&#10;                    checked = deviceData.disinfectionStatus,&#10;                    onCheckedChange = { enabled -&gt;&#10;                        // 更新本地状态&#10;                        deviceDataManager.updateDisinfectionStatus(enabled)&#10;                        // 发送控制指令到设备&#10;                        mqttService.sendDisinfectionCommand(enabled) { success, message -&gt;&#10;                            if (!success) {&#10;                                // 如果发送失败，回滚本地状态&#10;                                deviceDataManager.updateDisinfectionStatus(!enabled)&#10;                                android.util.Log.w(&quot;DeviceScreen&quot;, &quot;消毒控制指令发送失败: $message&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            // 第四行：加热状态&#10;            HeatingCard(&#10;                enabled = deviceData.heatingStatus,&#10;                onEnabledChange = { enabled -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateHeatingStatus(enabled)&#10;                    // 发送控制指令到设备&#10;                    mqttService.sendHeatingCommand(enabled) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateHeatingStatus(!enabled)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;加热控制指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                targetTemperature = deviceData.targetTemperature.toInt(),&#10;                onTemperatureChange = { temperature -&gt;&#10;                    // 更新本地状态&#10;                    deviceDataManager.updateTargetTemperature(temperature.toFloat())&#10;                    // 发送目标温度设置指令到设备&#10;                    mqttService.sendTargetTemperatureCommand(temperature) { success, message -&gt;&#10;                        if (!success) {&#10;                            // 如果发送失败，回滚本地状态&#10;                            deviceDataManager.updateTargetTemperature(deviceData.targetTemperature)&#10;                            android.util.Log.w(&quot;DeviceScreen&quot;, &quot;目标温度设置指令发送失败: $message&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;            )&#10;&#10;            // 第五行：云端监控视频模块&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            CloudVideoMonitorCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                context = context,&#10;                hapticFeedback = hapticFeedback,&#10;                audioRecordManager = audioRecordManager,&#10;                isRecording = isRecording,&#10;                volumeLevel = volumeLevel&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnvironmentCard(&#10;    label: String,&#10;    value: String,&#10;    chartData: List&lt;ChartDataPoint&gt;,&#10;    chartColor: Color,&#10;    modifier: Modifier = Modifier,&#10;    onClick: () -&gt; Unit = {}&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .height(120.dp)&#10;            .clickable(onClick = onClick),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(12.dp)&#10;        ) {&#10;            // 标题&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 16.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 数值&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.headlineSmall,&#10;                color = MaterialTheme.colorScheme.onSecondaryContainer,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            // 显示曲线图&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            MiniChart(&#10;                data = chartData,&#10;                lineColor = chartColor,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SwitchCard(&#10;    label: String,&#10;    checked: Boolean,&#10;    onCheckedChange: (Boolean) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(80.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (checked)&#10;                MaterialTheme.colorScheme.tertiaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)  // 关闭时为灰色状态&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = label,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (checked)&#10;                    MaterialTheme.colorScheme.onTertiaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f),  // 灰色文字&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;            Switch(&#10;                checked = checked,&#10;                onCheckedChange = onCheckedChange,&#10;                colors = SwitchDefaults.colors(&#10;                    checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                    checkedTrackColor = MaterialTheme.colorScheme.primaryContainer,&#10;                    uncheckedThumbColor = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f),&#10;                    uncheckedTrackColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f)&#10;                )&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun HeatingCard(&#10;    enabled: Boolean,&#10;    onEnabledChange: (Boolean) -&gt; Unit,&#10;    targetTemperature: Int,&#10;    onTemperatureChange: (Int) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier.height(100.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // 第一行：标题和开关&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;加热开关：${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Switch(&#10;                    checked = enabled,&#10;                    onCheckedChange = onEnabledChange,&#10;                    modifier = Modifier.size(32.dp),&#10;                    colors = SwitchDefaults.colors(&#10;                        checkedThumbColor = MaterialTheme.colorScheme.primary,&#10;                        checkedTrackColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // 第二行：温度控制&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &gt; 10) {&#10;                            onTemperatureChange(targetTemperature - 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Remove,&#10;                        contentDescription = &quot;降低温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;&#10;                Text(&#10;                    text = &quot;当前设定温度：${targetTemperature}°C&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                    fontWeight = FontWeight.Medium&#10;                )&#10;&#10;                IconButton(&#10;                    onClick = {&#10;                        if (targetTemperature &lt; 40) {&#10;                            onTemperatureChange(targetTemperature + 1)&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(32.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Add,&#10;                        contentDescription = &quot;提高温度&quot;,&#10;                        tint = MaterialTheme.colorScheme.onPrimaryContainer&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// 曲线图组件&#10;@Composable&#10;fun MiniChart(&#10;    data: List&lt;ChartDataPoint&gt;,&#10;    lineColor: Color,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Canvas(modifier = modifier) {&#10;        if (data.isEmpty()) return@Canvas&#10;&#10;        val width = size.width&#10;        val height = size.height&#10;        val padding = 8.dp.toPx()&#10;        val textHeight = 10.dp.toPx()&#10;&#10;        // 计算数据范围&#10;        val minValue = data.minOf { it.value }&#10;        val maxValue = data.maxOf { it.value }&#10;        val valueRange = maxValue - minValue&#10;&#10;        // 为时间标签留出空间&#10;        val chartHeight = height - textHeight - 4.dp.toPx()&#10;&#10;        // 创建路径&#10;        val path = Path()&#10;&#10;        data.forEachIndexed { index, point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            if (index == 0) {&#10;                path.moveTo(x, y)&#10;            } else {&#10;                path.lineTo(x, y)&#10;            }&#10;        }&#10;&#10;        // 绘制曲线&#10;        drawPath(&#10;            path = path,&#10;            color = lineColor,&#10;            style = Stroke(&#10;                width = 1.5.dp.toPx(),&#10;                cap = StrokeCap.Round,&#10;                join = StrokeJoin.Round&#10;            )&#10;        )&#10;&#10;        // 绘制数据点&#10;        data.forEach { point -&gt;&#10;            val x = padding + (width - 2 * padding) * (point.hour / 23f)&#10;            val y = padding + (chartHeight - 2 * padding) * (1 - (point.value - minValue) / valueRange)&#10;&#10;            drawCircle(&#10;                color = lineColor,&#10;                radius = 1.dp.toPx(),&#10;                center = Offset(x, y)&#10;            )&#10;        }&#10;&#10;        // 绘制时间轴文字标签&#10;        drawIntoCanvas { canvas -&gt;&#10;            val textPaint = android.graphics.Paint().apply {&#10;                color = Color.Gray.toArgb()&#10;                textSize = 8.sp.toPx()&#10;                isAntiAlias = true&#10;            }&#10;&#10;            // 绘制&quot;0:00&quot;标签&#10;            val startX = padding&#10;            val textY = height - 2.dp.toPx()&#10;            textPaint.textAlign = android.graphics.Paint.Align.LEFT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;0:00&quot;,&#10;                startX,&#10;                textY,&#10;                textPaint&#10;            )&#10;&#10;            // 绘制&quot;24:00&quot;标签&#10;            val endX = width - padding&#10;            textPaint.textAlign = android.graphics.Paint.Align.RIGHT&#10;            canvas.nativeCanvas.drawText(&#10;                &quot;24:00&quot;,&#10;                endX,&#10;                textY,&#10;                textPaint&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;// 云端视频监控状态枚举&#10;enum class VideoStreamStatus {&#10;    LOADING,    // 加载中&#10;    PLAYING,    // 播放中&#10;    PAUSED,     // 暂停&#10;    ERROR,      // 错误&#10;    OFFLINE     // 离线&#10;}&#10;&#10;// 视频流数据类&#10;data class VideoStreamInfo(&#10;    val streamUrl: String,&#10;    val resolution: String,&#10;    val quality: String,&#10;    val isLive: Boolean&#10;)&#10;&#10;@Composable&#10;fun CloudVideoMonitorCard(&#10;    modifier: Modifier = Modifier,&#10;    context: android.content.Context,&#10;    hapticFeedback: androidx.compose.ui.hapticfeedback.HapticFeedback,&#10;    audioRecordManager: AudioRecordManager,&#10;    isRecording: Boolean,&#10;    volumeLevel: Float&#10;) {&#10;    var videoStatus by remember { mutableStateOf(VideoStreamStatus.OFFLINE) }&#10;    var isPlaying by remember { mutableStateOf(false) }&#10;    var showSettings by remember { mutableStateOf(false) }&#10;&#10;    Card(&#10;        modifier = modifier.height(300.dp),&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // 标题栏&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;云端监控&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    // 实时状态指示器&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(&#10;                                when (videoStatus) {&#10;                                    VideoStreamStatus.PLAYING -&gt; Color(0xFF4CAF50)&#10;                                    VideoStreamStatus.LOADING -&gt; Color(0xFFFF9800)&#10;                                    VideoStreamStatus.ERROR -&gt; Color(0xFFF44336)&#10;                                    else -&gt; Color.Gray&#10;                                }&#10;                            )&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;&#10;                    Text(&#10;                        text = when (videoStatus) {&#10;                            VideoStreamStatus.PLAYING -&gt; &quot;直播中&quot;&#10;                            VideoStreamStatus.LOADING -&gt; &quot;连接中&quot;&#10;                            VideoStreamStatus.PAUSED -&gt; &quot;已暂停&quot;&#10;                            VideoStreamStatus.ERROR -&gt; &quot;连接失败&quot;&#10;                            VideoStreamStatus.OFFLINE -&gt; &quot;离线&quot;&#10;                        },&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)&#10;                    )&#10;                }&#10;&#10;                // 设置按钮&#10;                IconButton(&#10;                    onClick = { showSettings = !showSettings },&#10;                    modifier = Modifier.size(24.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Settings,&#10;                        contentDescription = &quot;设置&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.size(18.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // 视频播放区域&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(200.dp),&#10;                shape = RoundedCornerShape(8.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = Color.Black&#10;                )&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    when (videoStatus) {&#10;                        VideoStreamStatus.OFFLINE, VideoStreamStatus.ERROR -&gt; {&#10;                            Column(&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Default.Refresh,&#10;                                    contentDescription = &quot;重新连接&quot;,&#10;                                    tint = Color.White.copy(alpha = 0.6f),&#10;                                    modifier = Modifier.size(32.dp)&#10;                                )&#10;                                Spacer(modifier = Modifier.height(4.dp))&#10;                                Text(&#10;                                    text = if (videoStatus == VideoStreamStatus.ERROR) &quot;连接失败&quot; else &quot;点击连接&quot;,&#10;                                    color = Color.White.copy(alpha = 0.6f),&#10;                                    style = MaterialTheme.typography.bodySmall&#10;                                )&#10;                            }&#10;                        }&#10;                        VideoStreamStatus.LOADING -&gt; {&#10;                            Column(&#10;                                horizontalAlignment = Alignment.CenterHorizontally&#10;                            ) {&#10;                                CircularProgressIndicator(&#10;                                    color = Color.White,&#10;                                    modifier = Modifier.size(24.dp),&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                Text(&#10;                                    text = &quot;正在连接...&quot;,&#10;                                    color = Color.White.copy(alpha = 0.8f),&#10;                                    style = MaterialTheme.typography.bodySmall&#10;                                )&#10;                            }&#10;                        }&#10;                        VideoStreamStatus.PLAYING, VideoStreamStatus.PAUSED -&gt; {&#10;                            // TODO: 这里将来集成实际的视频播放器&#10;                            Box(&#10;                                modifier = Modifier&#10;                                    .fillMaxSize()&#10;                                    .background(Color.Black)&#10;                                    .clickable {&#10;                                        isPlaying = !isPlaying&#10;                                        videoStatus = if (isPlaying) VideoStreamStatus.PLAYING else VideoStreamStatus.PAUSED&#10;                                    },&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                if (videoStatus == VideoStreamStatus.PAUSED) {&#10;                                    Icon(&#10;                                        Icons.Default.PlayArrow,&#10;                                        contentDescription = &quot;播放&quot;,&#10;                                        tint = Color.White.copy(alpha = 0.8f),&#10;                                        modifier = Modifier.size(48.dp)&#10;                                    )&#10;                                }&#10;&#10;                                // 模拟视频内容（占位符）&#10;                                Text(&#10;                                    text = &quot;实时监控画面&quot;,&#10;                                    color = Color.White.copy(alpha = 0.5f),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    modifier = Modifier.align(Alignment.TopStart).padding(8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // 控制按钮区域&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly&#10;            ) {&#10;                // 播放/暂停按钮&#10;                IconButton(&#10;                    onClick = {&#10;                        when (videoStatus) {&#10;                            VideoStreamStatus.OFFLINE, VideoStreamStatus.ERROR -&gt; {&#10;                                videoStatus = VideoStreamStatus.LOADING&#10;                                // TODO: 启动视频流连接&#10;                                // 模拟连接延迟&#10;                                kotlin.concurrent.thread {&#10;                                    Thread.sleep(2000)&#10;                                    videoStatus = VideoStreamStatus.PLAYING&#10;                                    isPlaying = true&#10;                                }&#10;                            }&#10;                            VideoStreamStatus.PLAYING -&gt; {&#10;                                videoStatus = VideoStreamStatus.PAUSED&#10;                                isPlaying = false&#10;                            }&#10;                            VideoStreamStatus.PAUSED -&gt; {&#10;                                videoStatus = VideoStreamStatus.PLAYING&#10;                                isPlaying = true&#10;                            }&#10;                            else -&gt; {}&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        when (videoStatus) {&#10;                            VideoStreamStatus.PLAYING -&gt; Icons.Default.Pause&#10;                            else -&gt; Icons.Default.PlayArrow&#10;                        },&#10;                        contentDescription = if (isPlaying) &quot;暂停&quot; else &quot;播放&quot;,&#10;                        tint = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                // 刷新按钮&#10;                IconButton(&#10;                    onClick = {&#10;                        videoStatus = VideoStreamStatus.LOADING&#10;                        // TODO: 重新连接视频流&#10;                        kotlin.concurrent.thread {&#10;                            Thread.sleep(1500)&#10;                            videoStatus = VideoStreamStatus.PLAYING&#10;                            isPlaying = true&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Refresh,&#10;                        contentDescription = &quot;刷新&quot;,&#10;                        tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                // 对讲功能按钮&#10;                IconButton(&#10;                    onClick = {&#10;                        hapticFeedback.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                        if (isRecording) {&#10;                            // 如果当前正在录音，则停止录音&#10;                            audioRecordManager.stopRecording()&#10;                        } else {&#10;                            // 启动录音&#10;                            if (audioRecordManager.hasRecordPermission(context)) {&#10;                                audioRecordManager.startRecording(context)&#10;                            } else {&#10;                                android.util.Log.e(&quot;DeviceScreen&quot;, &quot;没有录音权限&quot;)&#10;                                // TODO: 请求录音权限&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.size(40.dp)&#10;                ) {&#10;                    Icon(&#10;                        if (isRecording) Icons.Default.MicOff else Icons.Default.Mic,&#10;                        contentDescription = if (isRecording) &quot;停止对讲&quot; else &quot;开始对讲&quot;,&#10;                        tint = if (isRecording) Color.Red else MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.size(24.dp)&#10;                    )&#10;                }&#10;&#10;                // 录音音量指示器（仅在录音时显示）&#10;                if (isRecording) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(40.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color.Red.copy(alpha = 0.1f)),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        // 音量级别指示器&#10;                        val animatedVolumeLevel by animateFloatAsState(&#10;                            targetValue = volumeLevel,&#10;                            animationSpec = tween(durationMillis = 100)&#10;                        )&#10;&#10;                        Canvas(modifier = Modifier.size(24.dp)) {&#10;                            drawCircle(&#10;                                color = Color.Red,&#10;                                radius = size.minDimension / 4 * (0.3f + animatedVolumeLevel * 0.7f)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 视频信息显示&#10;            if (videoStatus == VideoStreamStatus.PLAYING) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = &quot;1080P&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)&#10;                    )&#10;                    Text(&#10;                        text = &quot;延迟: 200ms&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DeviceScreenPreview() {&#10;    DeviceScreen()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/service/AudioRecordManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/service/AudioRecordManager.kt" />
              <option name="originalContent" value="package com.example.petnestiq.service&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.media.AudioFormat&#10;import android.media.AudioRecord&#10;import android.media.MediaRecorder&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.ByteArrayOutputStream&#10;&#10;/**&#10; * 音频录制管理器&#10; * 用于录制音频并通过MQTT发送语音数据&#10; */&#10;class AudioRecordManager private constructor() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AudioRecordManager&quot;&#10;&#10;        // 音频录制参数&#10;        private const val SAMPLE_RATE = 16000  // 采样率 16kHz&#10;        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO  // 单声道&#10;        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT  // 16位PCM&#10;        private const val BUFFER_SIZE_FACTOR = 2  // 缓冲区大小倍数&#10;&#10;        @Volatile&#10;        private var INSTANCE: AudioRecordManager? = null&#10;&#10;        fun getInstance(): AudioRecordManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: AudioRecordManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    private var audioRecord: AudioRecord? = null&#10;    private var recordingJob: Job? = null&#10;    private val recordingScope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;&#10;    // 录制状态&#10;    private val _isRecording = MutableStateFlow(false)&#10;    val isRecording: StateFlow&lt;Boolean&gt; = _isRecording.asStateFlow()&#10;&#10;    // 录制音量级别（用于UI显示）&#10;    private val _volumeLevel = MutableStateFlow(0f)&#10;    val volumeLevel: StateFlow&lt;Float&gt; = _volumeLevel.asStateFlow()&#10;&#10;    // MQTT服务实例&#10;    private val mqttService = HuaweiIoTDAMqttService.getInstance()&#10;&#10;    // 计算缓冲区大小&#10;    private val bufferSize: Int by lazy {&#10;        val minBufferSize = AudioRecord.getMinBufferSize(&#10;            SAMPLE_RATE,&#10;            CHANNEL_CONFIG,&#10;            AUDIO_FORMAT&#10;        )&#10;        minBufferSize * BUFFER_SIZE_FACTOR&#10;    }&#10;&#10;    /**&#10;     * 检查录音权限&#10;     */&#10;    fun hasRecordPermission(context: Context): Boolean {&#10;        return ActivityCompat.checkSelfPermission(&#10;            context,&#10;            Manifest.permission.RECORD_AUDIO&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    /**&#10;     * 开始录音&#10;     */&#10;    fun startRecording(context: Context) {&#10;        if (_isRecording.value) {&#10;            Log.w(TAG, &quot;已经在录音中&quot;)&#10;            return&#10;        }&#10;&#10;        if (!hasRecordPermission(context)) {&#10;            Log.e(TAG, &quot;没有录音权限&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // 创建AudioRecord实例&#10;            audioRecord = AudioRecord(&#10;                MediaRecorder.AudioSource.MIC,&#10;                SAMPLE_RATE,&#10;                CHANNEL_CONFIG,&#10;                AUDIO_FORMAT,&#10;                bufferSize&#10;            )&#10;&#10;            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {&#10;                Log.e(TAG, &quot;AudioRecord初始化失败&quot;)&#10;                releaseAudioRecord()&#10;                return&#10;            }&#10;&#10;            // 开始录制&#10;            audioRecord?.startRecording()&#10;            _isRecording.value = true&#10;&#10;            // 启动录制协程&#10;            recordingJob = recordingScope.launch {&#10;                recordAudio()&#10;            }&#10;&#10;            Log.d(TAG, &quot;开始录音&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;开始录音失败&quot;, e)&#10;            releaseAudioRecord()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 停止录音&#10;     */&#10;    fun stopRecording() {&#10;        if (!_isRecording.value) {&#10;            Log.w(TAG, &quot;当前没有在录音&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            _isRecording.value = false&#10;            recordingJob?.cancel()&#10;            audioRecord?.stop()&#10;            releaseAudioRecord()&#10;            _volumeLevel.value = 0f&#10;&#10;            Log.d(TAG, &quot;停止录音&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;停止录音失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 录制音频数据&#10;     */&#10;    private suspend fun recordAudio() {&#10;        val audioData = ByteArrayOutputStream()&#10;        val buffer = ByteArray(bufferSize)&#10;&#10;        try {&#10;            while (_isRecording.value &amp;&amp; !recordingJob?.isCancelled!!) {&#10;                val bytesRead = audioRecord?.read(buffer, 0, buffer.size) ?: 0&#10;&#10;                if (bytesRead &gt; 0) {&#10;                    // 保存音频数据&#10;                    audioData.write(buffer, 0, bytesRead)&#10;&#10;                    // 计算音量级别&#10;                    val volumeLevel = calculateVolumeLevel(buffer, bytesRead)&#10;                    _volumeLevel.value = volumeLevel&#10;&#10;                    // 每隔一定时间发送一次数据（流式传输）&#10;                    if (audioData.size() &gt;= SAMPLE_RATE * 2) { // 约1秒的数据&#10;                        val audioBytes = audioData.toByteArray()&#10;                        audioData.reset()&#10;&#10;                        // 发送音频数据到MQTT&#10;                        mqttService.sendVoiceData(audioBytes)&#10;                    }&#10;                }&#10;&#10;                // 短暂延迟，避免过度消耗CPU&#10;                delay(10)&#10;            }&#10;&#10;            // 录制结束后，发送剩余的音频数据&#10;            if (audioData.size() &gt; 0) {&#10;                val audioBytes = audioData.toByteArray()&#10;                mqttService.sendVoiceData(audioBytes)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;录制音频数据失败&quot;, e)&#10;        } finally {&#10;            audioData.close()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 计算音量级别&#10;     */&#10;    private fun calculateVolumeLevel(buffer: ByteArray, bytesRead: Int): Float {&#10;        var sum = 0.0&#10;        for (i in 0 until bytesRead step 2) {&#10;            if (i + 1 &lt; bytesRead) {&#10;                // 将两个字节组合成一个16位采样&#10;                val sample = (buffer[i + 1].toInt() shl 8) or (buffer[i].toInt() and 0xFF)&#10;                sum += (sample * sample).toDouble()&#10;            }&#10;        }&#10;&#10;        val rms = kotlin.math.sqrt(sum / (bytesRead / 2))&#10;        // 归一化到0-1范围&#10;        return (rms / 32768.0).toFloat().coerceIn(0f, 1f)&#10;    }&#10;&#10;    /**&#10;     * 释放AudioRecord资源&#10;     */&#10;    private fun releaseAudioRecord() {&#10;        try {&#10;            audioRecord?.release()&#10;            audioRecord = null&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;释放AudioRecord失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 清理资源&#10;     */&#10;    fun cleanup() {&#10;        stopRecording()&#10;        recordingScope.cancel()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.service&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.media.AudioFormat&#10;import android.media.AudioRecord&#10;import android.media.MediaRecorder&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.ByteArrayOutputStream&#10;&#10;/**&#10; * 音频录制管理器&#10; * 用于录制音频并通过MQTT发送语音数据&#10; */&#10;class AudioRecordManager private constructor() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AudioRecordManager&quot;&#10;&#10;        // 音频录制参数&#10;        private const val SAMPLE_RATE = 16000  // 采样率 16kHz&#10;        private const val CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO  // 单声道&#10;        private const val AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT  // 16位PCM&#10;        private const val BUFFER_SIZE_FACTOR = 2  // 缓冲区大小倍数&#10;&#10;        @Volatile&#10;        private var INSTANCE: AudioRecordManager? = null&#10;&#10;        fun getInstance(): AudioRecordManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: AudioRecordManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    private var audioRecord: AudioRecord? = null&#10;    private var recordingJob: Job? = null&#10;    private val recordingScope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;&#10;    // 录制状态&#10;    private val _isRecording = MutableStateFlow(false)&#10;    val isRecording: StateFlow&lt;Boolean&gt; = _isRecording.asStateFlow()&#10;&#10;    // 录制音量级别（用于UI显示）&#10;    private val _volumeLevel = MutableStateFlow(0f)&#10;    val volumeLevel: StateFlow&lt;Float&gt; = _volumeLevel.asStateFlow()&#10;&#10;    // MQTT服务实例&#10;    private val mqttService = HuaweiIoTDAMqttService.getInstance()&#10;&#10;    // 计算缓冲区大小&#10;    private val bufferSize: Int by lazy {&#10;        val minBufferSize = AudioRecord.getMinBufferSize(&#10;            SAMPLE_RATE,&#10;            CHANNEL_CONFIG,&#10;            AUDIO_FORMAT&#10;        )&#10;        minBufferSize * BUFFER_SIZE_FACTOR&#10;    }&#10;&#10;    /**&#10;     * 检查录音权限&#10;     */&#10;    fun hasRecordPermission(context: Context): Boolean {&#10;        return ActivityCompat.checkSelfPermission(&#10;            context,&#10;            Manifest.permission.RECORD_AUDIO&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    /**&#10;     * 开始录音&#10;     */&#10;    fun startRecording(context: Context) {&#10;        if (_isRecording.value) {&#10;            Log.w(TAG, &quot;已经在录音中&quot;)&#10;            return&#10;        }&#10;&#10;        if (!hasRecordPermission(context)) {&#10;            Log.e(TAG, &quot;没有录音权限&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // 创建AudioRecord实例&#10;            audioRecord = AudioRecord(&#10;                MediaRecorder.AudioSource.MIC,&#10;                SAMPLE_RATE,&#10;                CHANNEL_CONFIG,&#10;                AUDIO_FORMAT,&#10;                bufferSize&#10;            )&#10;&#10;            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {&#10;                Log.e(TAG, &quot;AudioRecord初始化失败&quot;)&#10;                releaseAudioRecord()&#10;                return&#10;            }&#10;&#10;            // 开始录制&#10;            audioRecord?.startRecording()&#10;            _isRecording.value = true&#10;&#10;            // 启动录制协程&#10;            recordingJob = recordingScope.launch {&#10;                recordAudio()&#10;            }&#10;&#10;            Log.d(TAG, &quot;开始录音&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;开始录音失败&quot;, e)&#10;            releaseAudioRecord()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 停止录音&#10;     */&#10;    fun stopRecording() {&#10;        if (!_isRecording.value) {&#10;            Log.w(TAG, &quot;当前没有在录音&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            _isRecording.value = false&#10;            recordingJob?.cancel()&#10;            audioRecord?.stop()&#10;            releaseAudioRecord()&#10;            _volumeLevel.value = 0f&#10;&#10;            Log.d(TAG, &quot;停止录音&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;停止录音失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 录制音频数据&#10;     */&#10;    private suspend fun recordAudio() {&#10;        val audioData = ByteArrayOutputStream()&#10;        val buffer = ByteArray(bufferSize)&#10;&#10;        try {&#10;            while (_isRecording.value &amp;&amp; !recordingJob?.isCancelled!!) {&#10;                val bytesRead = audioRecord?.read(buffer, 0, buffer.size) ?: 0&#10;&#10;                if (bytesRead &gt; 0) {&#10;                    // 保存音频数据&#10;                    audioData.write(buffer, 0, bytesRead)&#10;&#10;                    // 计算音量级别&#10;                    val volumeLevel = calculateVolumeLevel(buffer, bytesRead)&#10;                    _volumeLevel.value = volumeLevel&#10;&#10;                    // 每隔一定时间发送一次数据（流式传输）&#10;                    if (audioData.size() &gt;= SAMPLE_RATE * 2) { // 约1秒的数据&#10;                        val audioBytes = audioData.toByteArray()&#10;                        audioData.reset()&#10;&#10;                        // 发送音频数据到MQTT&#10;                        mqttService.sendVoiceData(audioBytes)&#10;                    }&#10;                }&#10;&#10;                // 短暂延迟，避免过度消耗CPU&#10;                delay(10)&#10;            }&#10;&#10;            // 录制结束后，发送剩余的音频数据&#10;            if (audioData.size() &gt; 0) {&#10;                val audioBytes = audioData.toByteArray()&#10;                mqttService.sendVoiceData(audioBytes)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;录制音频数据失败&quot;, e)&#10;        } finally {&#10;            audioData.close()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 计算音量级别&#10;     */&#10;    private fun calculateVolumeLevel(buffer: ByteArray, bytesRead: Int): Float {&#10;        var sum = 0.0&#10;        for (i in 0 until bytesRead step 2) {&#10;            if (i + 1 &lt; bytesRead) {&#10;                // 将两个字节组合成一个16位采样&#10;                val sample = (buffer[i + 1].toInt() shl 8) or (buffer[i].toInt() and 0xFF)&#10;                sum += (sample * sample).toDouble()&#10;            }&#10;        }&#10;&#10;        val rms = kotlin.math.sqrt(sum / (bytesRead / 2))&#10;        // 归一化到0-1范围&#10;        return (rms / 32768.0).toFloat().coerceIn(0f, 1f)&#10;    }&#10;&#10;    /**&#10;     * 释放AudioRecord资源&#10;     */&#10;    private fun releaseAudioRecord() {&#10;        try {&#10;            audioRecord?.release()&#10;            audioRecord = null&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;释放AudioRecord失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 清理资源&#10;     */&#10;    fun cleanup() {&#10;        stopRecording()&#10;        recordingScope.cancel()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/service/HuaweiIoTDAMqttService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/service/HuaweiIoTDAMqttService.kt" />
              <option name="originalContent" value="package com.example.petnestiq.service&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import android.widget.Toast&#10;import com.example.petnestiq.data.DeviceData&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.google.gson.Gson&#10;import com.google.gson.JsonObject&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import org.eclipse.paho.client.mqttv3.*&#10;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.atomic.AtomicReference&#10;import javax.crypto.Mac&#10;import javax.crypto.spec.SecretKeySpec&#10;import kotlin.random.Random&#10;&#10;/**&#10; * 华为云IOTDA平台MQTT服务&#10; */&#10;class HuaweiIoTDAMqttService private constructor() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;HuaweiIoTDAMqttService&quot;&#10;&#10;        @Volatile&#10;        private var INSTANCE: HuaweiIoTDAMqttService? = null&#10;&#10;        fun getInstance(): HuaweiIoTDAMqttService {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: HuaweiIoTDAMqttService().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    // MQTT连接配置&#10;    data class MqttConfig(&#10;        val serverUri: String,          // MQTT服务器地址&#10;        val deviceId: String,           // 设备ID&#10;        val deviceSecret: String = &quot;&quot;,  // 设备密钥（如果使用密钥生成密码）&#10;        val clientId: String,           // 客户端ID&#10;        val username: String,           // 用户名&#10;        val password: String,           // 密码&#10;        val port: Int = 8883           // 端口号&#10;    )&#10;&#10;    // MQTT客户端&#10;    private var mqttClient: MqttClient? = null&#10;    private var currentConfig: MqttConfig? = null&#10;    private val deviceDataManager = DeviceDataManager.getInstance()&#10;    private val gson = Gson()&#10;&#10;    // 连接状态&#10;    private var isConnected = false&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;&#10;    // 调试数据收集&#10;    private val _debugMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val debugMessages: StateFlow&lt;List&lt;String&gt;&gt; = _debugMessages.asStateFlow()&#10;&#10;    private val _lastReceivedData = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastReceivedData: StateFlow&lt;String?&gt; = _lastReceivedData.asStateFlow()&#10;&#10;    private val _lastSentCommand = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastSentCommand: StateFlow&lt;String?&gt; = _lastSentCommand.asStateFlow()&#10;&#10;    // 添加上下文引用用于显示Toast&#10;    private var appContext: Context? = null&#10;&#10;    // 命令响应回调映射&#10;    private val commandCallbacks = mutableMapOf&lt;String, (Boolean, String?) -&gt; Unit&gt;()&#10;&#10;    /**&#10;     * 配置MQTT连接信息&#10;     */&#10;    fun configure(config: MqttConfig) {&#10;        this.currentConfig = config&#10;    }&#10;&#10;    /**&#10;     * 连接到华为云IOTDA平台&#10;     */&#10;    fun connect(context: Context) {&#10;        val config = currentConfig ?: run {&#10;            Log.e(TAG, &quot;MQTT配置未设置&quot;)&#10;            deviceDataManager.updateConnectionStatus(&quot;配置错误&quot;)&#10;            return&#10;        }&#10;&#10;        appContext = context // 保存上下文引用&#10;&#10;        serviceScope.launch {&#10;            try {&#10;                disconnect() // 先断开已有连接&#10;&#10;                Log.i(TAG, &quot;开始连接MQTT服务器: ${config.serverUri}&quot;)&#10;                deviceDataManager.updateConnectionStatus(&quot;连接中...&quot;)&#10;&#10;                // 使用配置中的密码，如果为空则生成密码&#10;                val password = if (config.password.isNotEmpty()) {&#10;                    config.password&#10;                } else {&#10;                    generatePassword(config.deviceSecret)&#10;                }&#10;&#10;                // 创建MQTT客户端&#10;                mqttClient = MqttClient(config.serverUri, config.clientId, MemoryPersistence())&#10;&#10;                // 配置连接选项&#10;                val options = MqttConnectOptions().apply {&#10;                    userName = config.username&#10;                    this.password = password.toCharArray()&#10;                    isCleanSession = true&#10;                    connectionTimeout = 30&#10;                    keepAliveInterval = 60&#10;                    isAutomaticReconnect = true&#10;                }&#10;&#10;                // 设置回调&#10;                mqttClient?.setCallback(createMqttCallback())&#10;&#10;                // 连接&#10;                mqttClient?.connect(options)&#10;&#10;                // 订阅多个topic来接收设备数据&#10;                subscribeToTopics(config.deviceId)&#10;&#10;                isConnected = true&#10;                Log.i(TAG, &quot;MQTT连接成功&quot;)&#10;                deviceDataManager.updateConnectionStatus(&quot;MQTT连接&quot;)&#10;&#10;                // 开始定期获取设备状态&#10;                startDataPolling()&#10;&#10;                // 开始监听设备状态变化并发送控制消息&#10;                startDeviceStateMonitoring()&#10;&#10;                // 移除监控设备状态变化并下发指令的功能，因为不需要上报数据给MQTT平台&#10;                // startCommandMonitoring()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;MQTT连接失败&quot;, e)&#10;                isConnected = false&#10;                deviceDataManager.updateConnectionStatus(&quot;连接失败&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 订阅所有相关的MQTT Topic&#10;     */&#10;    private fun subscribeToTopics(deviceId: String) {&#10;        try {&#10;            val topics = listOf(&#10;                // 设备影子相关&#10;                &quot;\$oc/devices/$deviceId/sys/shadow/get/response&quot;,&#10;                &quot;\$oc/devices/$deviceId/sys/shadow/update/response&quot;,&#10;&#10;                // 设备属性上报&#10;                &quot;\$oc/devices/$deviceId/sys/properties/report&quot;,&#10;&#10;                // 设备消息上报&#10;                &quot;\$oc/devices/$deviceId/sys/messages/up&quot;,&#10;&#10;                // 设备事件上报&#10;                &quot;\$oc/devices/$deviceId/sys/events/up&quot;,&#10;&#10;                // 命令响应&#10;                &quot;\$oc/devices/$deviceId/sys/commands/response&quot;,&#10;&#10;                // 通用数据上报topic（根据华为云IoTDA的实际配置）&#10;                &quot;devices/$deviceId/data&quot;,&#10;                &quot;data/$deviceId&quot;,&#10;                &quot;$deviceId/data&quot;,&#10;&#10;                // 可能的自定义topic&#10;                &quot;topic/$deviceId/data&quot;,&#10;                &quot;iot/$deviceId/data&quot;&#10;            )&#10;&#10;            topics.forEach { topic -&gt;&#10;                try {&#10;                    mqttClient?.subscribe(topic, 1)&#10;                    Log.i(TAG, &quot;订阅Topic: $topic&quot;)&#10;                    addDebugMessage(&quot;订阅Topic: $topic&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;订阅Topic失败: $topic&quot;, e)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;批量订阅Topic失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 断开MQTT连接&#10;     */&#10;    fun disconnect() {&#10;        try {&#10;            if (mqttClient?.isConnected == true) {&#10;                mqttClient?.disconnect()&#10;            }&#10;            mqttClient?.close()&#10;            mqttClient = null&#10;            isConnected = false&#10;            Log.i(TAG, &quot;MQTT连接已断开&quot;)&#10;            deviceDataManager.updateConnectionStatus(null)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;断开MQTT连接时出错&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 获取设备影子状态&#10;     */&#10;    fun getDeviceShadow() {&#10;        val config = currentConfig ?: return&#10;        if (!isConnected || mqttClient?.isConnected != true) return&#10;&#10;        try {&#10;            val requestId = generateRequestId()&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/shadow/get/request_id=$requestId&quot;&#10;&#10;            val message = JsonObject().apply {&#10;                addProperty(&quot;object_device_id&quot;, config.deviceId)&#10;                addProperty(&quot;service_id&quot;, &quot;dataText&quot;)&#10;            }&#10;&#10;            val mqttMessage = MqttMessage(message.toString().toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;            Log.d(TAG, &quot;发送设备影子获取请求: $topic&quot;)&#10;            Log.d(TAG, &quot;请求消息内容: ${message.toString()}&quot;)&#10;            addDebugMessage(&quot;发送�������备影子请求: ${message.toString()}&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;获取设备影子失败&quot;, e)&#10;            addDebugMessage(&quot;设备影子请求失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送设备指令&#10;     */&#10;    private fun sendDeviceCommand(commandType: String, commandValue: Any) {&#10;        val config = currentConfig ?: return&#10;        if (!isConnected || mqttClient?.isConnected != true) return&#10;&#10;        try {&#10;            val requestId = generateRequestId()&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/commands/request_id=$requestId&quot;&#10;&#10;            val command = JsonObject().apply {&#10;                addProperty(&quot;object_device_id&quot;, config.deviceId)&#10;                addProperty(&quot;service_id&quot;, &quot;ControlService&quot;)&#10;&#10;                val paras = JsonObject().apply {&#10;                    addProperty(commandType, commandValue.toString())&#10;                }&#10;                add(&quot;paras&quot;, paras)&#10;            }&#10;&#10;            val commandJson = command.toString()&#10;            val mqttMessage = MqttMessage(commandJson.toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;            Log.d(TAG, &quot;发送设备指令: $commandType = $commandValue&quot;)&#10;&#10;            // 记录调试数据&#10;            addDebugMessage(&quot;发送指令: $commandType = $commandValue&quot;)&#10;            _lastSentCommand.value = commandJson&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送设备指令失败&quot;, e)&#10;            addDebugMessage(&quot;发送指令失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 开始数据轮询&#10;     */&#10;    private fun startDataPolling() {&#10;        serviceScope.launch {&#10;            while (isConnected) {&#10;                try {&#10;                    getDeviceShadow()&#10;                    delay(10000) // 每10秒获取一次数据&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;数据轮询出错&quot;, e)&#10;                    delay(5000)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 创建MQTT回调&#10;     */&#10;    private fun createMqttCallback(): MqttCallback {&#10;        return object : MqttCallback {&#10;            override fun connectionLost(cause: Throwable?) {&#10;                Log.w(TAG, &quot;MQTT连接丢失&quot;, cause)&#10;                isConnected = false&#10;                deviceDataManager.updateConnectionStatus(&quot;连接断开&quot;)&#10;            }&#10;&#10;            override fun messageArrived(topic: String?, message: MqttMessage?) {&#10;                try {&#10;                    val payload = message?.payload?.let { String(it) } ?: return&#10;                    Log.d(TAG, &quot;收到消息 topic: $topic, payload: $payload&quot;)&#10;&#10;                    // 记录调试数据&#10;                    addDebugMessage(&quot;收到消息: $topic&quot;)&#10;                    addDebugMessage(&quot;数据内容: $payload&quot;)&#10;                    _lastReceivedData.value = payload&#10;&#10;                    // 根据topic类型解析不同的消息&#10;                    when {&#10;                        topic?.contains(&quot;shadow/get/response&quot;) == true -&gt; {&#10;                            parseDeviceShadowResponse(payload)&#10;                        }&#10;                        topic?.contains(&quot;properties/report&quot;) == true -&gt; {&#10;                            parsePropertyReport(payload)&#10;                        }&#10;                        topic?.contains(&quot;messages/up&quot;) == true -&gt; {&#10;                            parseDeviceMessage(payload)&#10;                        }&#10;                        topic?.contains(&quot;events/up&quot;) == true -&gt; {&#10;                            parseDeviceEvent(payload)&#10;                        }&#10;                        topic?.contains(&quot;commands/response&quot;) == true -&gt; {&#10;                            parseCommandResponse(payload)&#10;                        }&#10;                        topic?.contains(&quot;/data&quot;) == true -&gt; {&#10;                            parseGenericData(payload)&#10;                        }&#10;                        else -&gt; {&#10;                            // 尝试通用解析&#10;                            parseGenericData(payload)&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;处理MQTT消息失败&quot;, e)&#10;                    addDebugMessage(&quot;处理消息失败: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            override fun deliveryComplete(token: IMqttDeliveryToken?) {&#10;                Log.d(TAG, &quot;消息发送完成&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析设备影子响应&#10;     */&#10;    private fun parseDeviceShadowResponse(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析设备影子响应: $payload&quot;)&#10;            addDebugMessage(&quot;解析设备影子数据: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 支持多种JSON格式解析&#10;            var properties: JsonObject? = null&#10;&#10;            // 1. 解析您的平台格式: shadow[0].reported.properties&#10;            json.getAsJsonArray(&quot;shadow&quot;)?.let { shadowArray -&gt;&#10;                if (shadowArray.size() &gt; 0) {&#10;                    val shadowObj = shadowArray.get(0).asJsonObject&#10;                    val reportedObj = shadowObj.getAsJsonObject(&quot;reported&quot;)&#10;                    if (reportedObj != null) {&#10;                        properties = reportedObj.getAsJsonObject(&quot;properties&quot;)&#10;                        if (properties != null) {&#10;                            Log.d(TAG, &quot;使用平台格式解析: shadow[0].reported.properties&quot;)&#10;                            addDebugMessage(&quot;使用平台格式解析数据&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 2. 如果上述格式不存在，尝试华为云标准格式: shadow.reported[0].properties&#10;            if (properties == null) {&#10;                json.getAsJsonObject(&quot;shadow&quot;)?.getAsJsonArray(&quot;reported&quot;)?.let { reportedArray -&gt;&#10;                    if (reportedArray.size() &gt; 0) {&#10;                        val reportedObj = reportedArray.get(0).asJsonObject&#10;                        properties = reportedObj.getAsJsonObject(&quot;properties&quot;)&#10;                        if (properties != null) {&#10;                            Log.d(TAG, &quot;使用华为云标准格式解析: shadow.reported[0].properties&quot;)&#10;                            addDebugMessage(&quot;使用华为云标准格式解析数据&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 3. 如果标准格式不存在，尝试直接从根级别的properties解析&#10;            if (properties == null &amp;&amp; json.has(&quot;properties&quot;)) {&#10;                properties = json.getAsJsonObject(&quot;properties&quot;)&#10;                Log.d(TAG, &quot;使用根级别properties格式解析&quot;)&#10;                addDebugMessage(&quot;使用根级别properties格式解析数据&quot;)&#10;            }&#10;&#10;            // 4. 如果都不存在，尝试直接从根级别解析所有数据&#10;            if (properties == null) {&#10;                properties = json&#10;                Log.d(TAG, &quot;使用根级别直接解析&quot;)&#10;                addDebugMessage(&quot;使用根级别直接解析数据&quot;)&#10;            }&#10;&#10;            if (properties != null &amp;&amp; properties.size() &gt; 0) {&#10;                var hasUpdatedData = false&#10;&#10;                // 解析温度&#10;                properties.get(&quot;temperature&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val temperature = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        temperature?.let {&#10;                            deviceDataManager.updateTemperature(it)&#10;                            Log.d(TAG, &quot;✅ 更新温度: ${it}°C&quot;)&#10;                            addDebugMessage(&quot;✅ 更新温度: ${it}°C&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析温度失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析温度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析湿度&#10;                properties.get(&quot;humidity&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val humidity = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        humidity?.let {&#10;                            deviceDataManager.updateHumidity(it)&#10;                            Log.d(TAG, &quot;✅ 更新湿度: ${it}%&quot;)&#10;                            addDebugMessage(&quot;✅ 更新湿度: ${it}%&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析湿度失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析湿度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析食物量&#10;                properties.get(&quot;food_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val foodAmount = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        foodAmount?.let {&#10;                            deviceDataManager.updateFoodAmount(it)&#10;                            Log.d(TAG, &quot;✅ 更新食物量: ${it}g&quot;)&#10;                            addDebugMessage(&quot;✅ 更新食物量: ${it}g&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析食物量失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析食物量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析水量&#10;                properties.get(&quot;water_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val waterAmount = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        waterAmount?.let {&#10;                            deviceDataManager.updateWaterAmount(it)&#10;                            Log.d(TAG, &quot;✅ 更新水量: ${it}ml&quot;)&#10;                            addDebugMessage(&quot;✅ 更新水量: ${it}ml&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析水量失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析水量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析通风状态&#10;                properties.get(&quot;ventilation_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val ventilation = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateVentilationStatus(ventilation)&#10;                        Log.d(TAG, &quot;✅ 更新通风状态: $ventilation&quot;)&#10;                        addDebugMessage(&quot;✅ 更新通风状态: $ventilation&quot;)&#10;                        hasUpdatedData = true&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析通风状态失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析通风状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析消毒状态&#10;                properties.get(&quot;disinfection_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val disinfection = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateDisinfectionStatus(disinfection)&#10;                        Log.d(TAG, &quot;✅ 更新消毒状态: $disinfection&quot;)&#10;                        addDebugMessage(&quot;✅ 更新消毒状态: $disinfection&quot;)&#10;                        hasUpdatedData = true&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析消毒状态失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析消毒状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析加热状态&#10;                properties.get(&quot;heating_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val heating = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateHeatingStatus(heating)&#10;                        Log.d(TAG, &quot;✅ 更新加热状态: $heating&quot;)&#10;                        addDebugMessage(&quot;✅ 更新加热状态: $heating&quot;)&#10;                        hasUpdatedData = true&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析加热状态失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析加热状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                if (hasUpdatedData) {&#10;                    Log.d(TAG, &quot; 设备数据更新成功&quot;)&#10;                    addDebugMessage(&quot; 设备数据更新成功&quot;)&#10;                } else {&#10;                    Log.w(TAG, &quot;⚠️ 未能解析出任何有效数据&quot;)&#10;                    addDebugMessage(&quot;⚠️ 未能解析出有效数据&quot;)&#10;&#10;                    // 输出所有可用的字段名以便调试&#10;                    val availableKeys = properties.keySet().toList()&#10;                    Log.d(TAG, &quot;可用字段: $availableKeys&quot;)&#10;                    addDebugMessage(&quot;可用字段: $availableKeys&quot;)&#10;                }&#10;            } else {&#10;                Log.w(TAG, &quot;❌ 未找到有效的属性数据&quot;)&#10;                addDebugMessage(&quot;❌ 未找到有效的属性数据&quot;)&#10;&#10;                // 输出整个JSON结构以便调试&#10;                Log.d(TAG, &quot;完整JSON结构: ${json.toString()}&quot;)&#10;                addDebugMessage(&quot;完整JSON: ${json.toString()}&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ 解析设备影子响应失败&quot;, e)&#10;            addDebugMessage(&quot;❌ 解析失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析属性报告&#10;     */&#10;    private fun parsePropertyReport(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析属性报告: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val properties = json&#10;&#10;            if (properties != null) {&#10;                // 解析温度&#10;                properties.get(&quot;temperature&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val temperature = element.asFloat&#10;                        deviceDataManager.updateTemperature(temperature)&#10;                        Log.d(TAG, &quot;更新温度: $temperature°C&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析温度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析湿度&#10;                properties.get(&quot;humidity&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val humidity = element.asFloat&#10;                        deviceDataManager.updateHumidity(humidity)&#10;                        Log.d(TAG, &quot;更新湿度: $humidity%&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析湿度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析食物量&#10;                properties.get(&quot;food_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val foodAmount = element.asFloat&#10;                        deviceDataManager.updateFoodAmount(foodAmount)&#10;                        Log.d(TAG, &quot;更新食物量: ${foodAmount}g&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析食物量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析水量&#10;                properties.get(&quot;water_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val waterAmount = element.asFloat&#10;                        deviceDataManager.updateWaterAmount(waterAmount)&#10;                        Log.d(TAG, &quot;更新水量: ${waterAmount}ml&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析水量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析通风状态&#10;                properties.get(&quot;ventilation_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val ventilation = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateVentilationStatus(ventilation)&#10;                        Log.d(TAG, &quot;更新通风状态: $ventilation&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;��析通风状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析消毒状态&#10;                properties.get(&quot;disinfection_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val disinfection = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateDisinfectionStatus(disinfection)&#10;                        Log.d(TAG, &quot;更新消毒状态: $disinfection&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析消毒状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析加热状态&#10;                properties.get(&quot;heating_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val heating = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateHeatingStatus(heating)&#10;                        Log.d(TAG, &quot;更新加热状态: $heating&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析加热状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析目标温度&#10;                properties.get(&quot;target_temperature&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val targetTemp = element.asFloat&#10;                        deviceDataManager.updateTargetTemperature(targetTemp)&#10;                        Log.d(TAG, &quot;更新目标温度: $targetTemp°C&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析目标温度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;设备状态更新成功&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的属性数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析属性报告失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析设备消息&#10;     */&#10;    private fun parseDeviceMessage(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析设备消息: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val messageData = json&#10;&#10;            if (messageData != null) {&#10;                // TODO: 根据实际消息内容解析并处理&#10;&#10;                Log.d(TAG, &quot;设备消息解析成功: $messageData&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的消息数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析设备消息失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析设备事件&#10;     */&#10;    private fun parseDeviceEvent(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析设备事件: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val eventData = json&#10;&#10;            if (eventData != null) {&#10;                // TODO: 根据实际事件内容解析并处理&#10;&#10;                Log.d(TAG, &quot;设备事件解析成功: $eventData&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的事件数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析设备事件失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析通用数据&#10;     */&#10;    private fun parseGenericData(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析通用数据: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val data = json&#10;&#10;            if (data != null) {&#10;                // TODO: 根据实际数据内容解析并处理&#10;&#10;                Log.d(TAG, &quot;通用数据解析成功: $data&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析通用数据失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成HMAC-SHA256密码&#10;     */&#10;    private fun generatePassword(deviceSecret: String): String {&#10;        try {&#10;            val timestamp = SimpleDateFormat(&quot;yyyyMMddHH&quot;, Locale.getDefault()).format(Date())&#10;            val mac = Mac.getInstance(&quot;HmacSHA256&quot;)&#10;            val secretKeySpec = SecretKeySpec(timestamp.toByteArray(), &quot;HmacSHA256&quot;)&#10;            mac.init(secretKeySpec)&#10;            val result = mac.doFinal(deviceSecret.toByteArray())&#10;            return result.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;生成密码失败&quot;, e)&#10;            return deviceSecret&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成请求ID&#10;     */&#10;    private fun generateRequestId(): String {&#10;        return &quot;req_${System.currentTimeMillis()}_${Random.nextInt(1000, 9999)}&quot;&#10;    }&#10;&#10;    /**&#10;     * 获取连接状态&#10;     */&#10;    fun isConnected(): Boolean = isConnected&#10;&#10;    /**&#10;     * 添加调试消息&#10;     */&#10;    private fun addDebugMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        val debugMessage = &quot;[$timestamp] $message&quot;&#10;&#10;        val currentMessages = _debugMessages.value.toMutableList()&#10;        currentMessages.add(0, debugMessage) // 添加到列表开头&#10;&#10;        // 保持最多50条调试消息&#10;        if (currentMessages.size &gt; 50) {&#10;            currentMessages.removeAt(currentMessages.size - 1)&#10;        }&#10;&#10;        _debugMessages.value = currentMessages&#10;    }&#10;&#10;    /**&#10;     * 清������试消息&#10;     */&#10;    fun clearDebugMessages() {&#10;        _debugMessages.value = emptyList()&#10;    }&#10;&#10;    /**&#10;     * 获取MQTT配置信息&#10;     */&#10;    fun getMqttConfig(): MqttConfig? = currentConfig&#10;&#10;    /**&#10;     * 清理资源&#10;     */&#10;    fun cleanup() {&#10;        serviceScope.cancel()&#10;        disconnect()&#10;    }&#10;&#10;    /**&#10;     * 下发设备消息 - 根据华为云IoTDA平台标准&#10;     * 参考文档: https://support.huaweicloud.com/api-iothub/iot_06_v5_0059.html&#10;     */&#10;    fun sendDeviceMessage(&#10;        ventilation: Int? = null,&#10;        disinfection: Int? = null,&#10;        heating: Int? = null,&#10;        targetTemperature: Int? = null,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        val config = currentConfig ?: run {&#10;            val errorMsg = &quot;MQTT配置未设置&quot;&#10;            Log.e(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        if (!isConnected || mqttClient?.isConnected != true) {&#10;            val errorMsg = &quot;MQTT未连接，无法发送消息&quot;&#10;            Log.w(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        // 检查参数有效性 - 至少要有一个控制参数&#10;        if (ventilation == null &amp;&amp; disinfection == null &amp;&amp; heating == null &amp;&amp; targetTemperature == null) {&#10;            val errorMsg = &quot;至少需要设置一个控制参数&quot;&#10;            Log.w(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            return&#10;        }&#10;&#10;        // 检查状态冲突&#10;        val hasConflict = checkDeviceStateConflict(&#10;            ventilation == 1,&#10;            disinfection == 1,&#10;            heating == 1&#10;        )&#10;        if (hasConflict) {&#10;            val errorMsg = &quot;设备状态冲突，无法执行操作&quot;&#10;            Log.w(TAG, &quot;⚠️ $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val requestId = generateRequestId()&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/commands/request_id=$requestId&quot;&#10;&#10;            // 构建控制指令 - 只包含控制参数，不包含状态数据&#10;            val paras = JsonObject()&#10;&#10;            // 只添加需要控制的参数&#10;            ventilation?.let { paras.addProperty(&quot;ventilation&quot;, it) }&#10;            disinfection?.let { paras.addProperty(&quot;disinfection&quot;, it) }&#10;            heating?.let { paras.addProperty(&quot;heating&quot;, it) }&#10;            targetTemperature?.let { paras.addProperty(&quot;target_temperature&quot;, it) }&#10;&#10;            val command = JsonObject().apply {&#10;                addProperty(&quot;object_device_id&quot;, config.deviceId)&#10;                addProperty(&quot;service_id&quot;, &quot;ControlService&quot;)&#10;                add(&quot;paras&quot;, paras)&#10;            }&#10;&#10;            val commandJson = command.toString()&#10;            val mqttMessage = MqttMessage(commandJson.toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            // 注册回调&#10;            onResult?.let { callback -&gt;&#10;                commandCallbacks[requestId] = callback&#10;&#10;                // 设置超时处理&#10;                serviceScope.launch {&#10;                    delay(10000) // 10秒超时&#10;                    if (commandCallbacks.containsKey(requestId)) {&#10;                        commandCallbacks.remove(requestId)&#10;                        val timeoutMsg = &quot;指���发送超时&quot;&#10;                        callback(false, timeoutMsg)&#10;                        showToast(timeoutMsg)&#10;                    }&#10;                }&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;&#10;            // 记录日志&#10;            val commandParams = mutableListOf&lt;String&gt;()&#10;            ventilation?.let { commandParams.add(&quot;通风开关=${if (it == 1) &quot;开&quot; else &quot;关&quot;}&quot;) }&#10;            disinfection?.let { commandParams.add(&quot;消毒开关=${if (it == 1) &quot;开&quot; else &quot;关&quot;}&quot;) }&#10;            heating?.let { commandParams.add(&quot;加热开关=${if (it == 1) &quot;开&quot; else &quot;关&quot;}&quot;) }&#10;            targetTemperature?.let { commandParams.add(&quot;设定温度=${it}°C&quot;) }&#10;&#10;            val commandDescription = commandParams.joinToString(&quot;, &quot;)&#10;            Log.d(TAG, &quot;✅ 发送控制指令: $commandDescription&quot;)&#10;            addDebugMessage(&quot;✅ 发送控制指令: $commandDescription&quot;)&#10;            addDebugMessage(&quot; 指令内容: $commandJson&quot;)&#10;&#10;            _lastSentCommand.value = commandJson&#10;&#10;        } catch (e: Exception) {&#10;            val errorMsg = &quot;发送控制指令失败: ${e.message}&quot;&#10;            Log.e(TAG, &quot;❌ $errorMsg&quot;, e)&#10;            addDebugMessage(&quot;❌ $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送通风控制指令&#10;     */&#10;    fun sendVentilationCommand(enabled: Boolean, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;ventilation&quot;, if (enabled) 1 else 0)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送通风控制指令: $enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送通风控制指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送消毒控制指令&#10;     */&#10;    fun sendDisinfectionCommand(enabled: Boolean, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;disinfection&quot;, if (enabled) 1 else 0)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送消毒控制指令: $enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送消毒控制指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送加热控制指令&#10;     */&#10;    fun sendHeatingCommand(enabled: Boolean, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;heating&quot;, if (enabled) 1 else 0)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送加热控制指令: $enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送加热控制指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送目标温度设置指令&#10;     */&#10;    fun sendTargetTemperatureCommand(temperature: Int, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;target_temperature&quot;, temperature)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送目标温度设置指令: $temperature&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送目标温度设置指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 批量控制设备状态 - 带结果回调&#10;     */&#10;    fun controlDeviceState(&#10;        ventilation: Boolean? = null,&#10;        disinfection: Boolean? = null,&#10;        heating: Boolean? = null,&#10;        targetTemperature: Int? = null,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        // 转换为数值参数&#10;        val ventilationValue = ventilation?.let { if (it) 1 else 0 }&#10;        val disinfectionValue = disinfection?.let { if (it) 1 else 0 }&#10;        val heatingValue = heating?.let { if (it) 1 else 0 }&#10;&#10;        Log.d(TAG, &quot;批量控制设备状态&quot;)&#10;        sendDeviceMessage(&#10;            ventilation = ventilationValue,&#10;            disinfection = disinfectionValue,&#10;            heating = heatingValue,&#10;            targetTemperature = targetTemperature,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报设备控制状态到MQTT服务器&#10;     * Topic: $oc/devices/{device_id}/sys/messages/up&#10;     */&#10;    fun reportControlStatus(&#10;        ventilation: Boolean,&#10;        disinfection: Boolean,&#10;        heating: Boolean,&#10;        targetTemperature: Int,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        val config = currentConfig ?: run {&#10;            val errorMsg = &quot;MQTT配置未设置&quot;&#10;            Log.e(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        if (!isConnected || mqttClient?.isConnected != true) {&#10;            val errorMsg = &quot;MQTT未连��，无法上报数据&quot;&#10;            Log.w(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/messages/up&quot;&#10;&#10;            // 获取当前设备数据以包含完整的状态信息&#10;            val currentData = deviceDataManager.deviceData.value&#10;&#10;            // 构建符合华为云IoTDA标准的消息格式&#10;            val properties = JsonObject().apply {&#10;                // 包含传感器数据&#10;                addProperty(&quot;temperature&quot;, currentData.temperature)&#10;                addProperty(&quot;humidity&quot;, currentData.humidity)&#10;                addProperty(&quot;food_amount&quot;, currentData.foodAmount)&#10;                addProperty(&quot;water_amount&quot;, currentData.waterAmount)&#10;&#10;                // 添加控制状态&#10;                addProperty(&quot;ventilation_status&quot;, ventilation)&#10;                addProperty(&quot;disinfection_status&quot;, disinfection)&#10;                addProperty(&quot;heating_status&quot;, heating)&#10;                addProperty(&quot;target_temperature&quot;, targetTemperature)&#10;            }&#10;&#10;            val service = JsonObject().apply {&#10;                addProperty(&quot;service_id&quot;, &quot;dataText&quot;)&#10;                add(&quot;properties&quot;, properties)&#10;                addProperty(&quot;eventTime&quot;, SimpleDateFormat(&quot;yyyyMMdd'T'HHmmss'Z'&quot;, Locale.getDefault()).format(Date()))&#10;            }&#10;&#10;            val services = com.google.gson.JsonArray().apply {&#10;                add(service)&#10;            }&#10;&#10;            val message = JsonObject().apply {&#10;                add(&quot;services&quot;, services)&#10;            }&#10;&#10;            val messageJson = message.toString()&#10;            val mqttMessage = MqttMessage(messageJson.toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;&#10;            // 记录日志&#10;            val statusDescription = &quot;通风=${if (ventilation) &quot;开&quot; else &quot;关&quot;}, &quot; +&#10;                    &quot;消毒=${if (disinfection) &quot;开&quot; else &quot;关&quot;}, &quot; +&#10;                    &quot;加热=${if (heating) &quot;开&quot; else &quot;关&quot;}, &quot; +&#10;                    &quot;目标温度=${targetTemperature}°C&quot;&#10;&#10;            Log.d(TAG, &quot;✅ 上报控制状态: $statusDescription&quot;)&#10;            addDebugMessage(&quot;✅ 上报控制状态: $statusDescription&quot;)&#10;            addDebugMessage(&quot; 上报数据: $messageJson&quot;)&#10;&#10;            _lastSentCommand.value = messageJson&#10;&#10;            // 立即调用成功回调（因为上报不需要设备响应）&#10;            onResult?.invoke(true, &quot;控制状态上报成功&quot;)&#10;            showToast(&quot;控制状态上报成功&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            val errorMsg = &quot;上报控制状态失败: ${e.message}&quot;&#10;            Log.e(TAG, &quot;❌ $errorMsg&quot;, e)&#10;            addDebugMessage(&quot;�� $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 上报通风开关状态&#10;     */&#10;    fun reportVentilationStatus(enabled: Boolean, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报通风开关状态: ${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentDisinfection = currentData.disinfectionStatus ?: false&#10;        val currentHeating = currentData.heatingStatus ?: false&#10;        val currentTargetTemp = currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        reportControlStatus(&#10;            ventilation = enabled,&#10;            disinfection = currentDisinfection,&#10;            heating = currentHeating,&#10;            targetTemperature = currentTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报消毒开关状态&#10;     */&#10;    fun reportDisinfectionStatus(enabled: Boolean, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报消毒开关状态: ${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentVentilation = currentData.ventilationStatus ?: false&#10;        val currentHeating = currentData.heatingStatus ?: false&#10;        val currentTargetTemp = currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        reportControlStatus(&#10;            ventilation = currentVentilation,&#10;            disinfection = enabled,&#10;            heating = currentHeating,&#10;            targetTemperature = currentTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报加热开关状态&#10;     */&#10;    fun reportHeatingStatus(enabled: Boolean, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报加热开关状态: ${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentVentilation = currentData.ventilationStatus ?: false&#10;        val currentDisinfection = currentData.disinfectionStatus ?: false&#10;        val currentTargetTemp = currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        reportControlStatus(&#10;            ventilation = currentVentilation,&#10;            disinfection = currentDisinfection,&#10;            heating = enabled,&#10;            targetTemperature = currentTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报目标温度设置&#10;     */&#10;    fun reportTargetTemperature(temperature: Int, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报目标温度设置: ${temperature}°C&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentVentilation = currentData.ventilationStatus ?: false&#10;        val currentDisinfection = currentData.disinfectionStatus ?: false&#10;        val currentHeating = currentData.heatingStatus ?: false&#10;&#10;        reportControlStatus(&#10;            ventilation = currentVentilation,&#10;            disinfection = currentDisinfection,&#10;            heating = currentHeating,&#10;            targetTemperature = temperature,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 批量上报设备控制状态（带状态冲突检查）&#10;     */&#10;    fun reportDeviceControlState(&#10;        ventilation: Boolean? = null,&#10;        disinfection: Boolean? = null,&#10;        heating: Boolean? = null,&#10;        targetTemperature: Int? = null,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        // 获取当前状态作为默认值&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val finalVentilation = ventilation ?: currentData.ventilationStatus ?: false&#10;        val finalDisinfection = disinfection ?: currentData.disinfectionStatus ?: false&#10;        val finalHeating = heating ?: currentData.heatingStatus ?: false&#10;        val finalTargetTemp = targetTemperature ?: currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        // 检查状态冲突&#10;        val hasConflict = checkDeviceStateConflict(finalVentilation, finalDisinfection, finalHeating)&#10;        if (hasConflict) {&#10;            val errorMsg = &quot;设备状态冲突，无法上报&quot;&#10;            Log.w(TAG, &quot;⚠️ $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;批量上报设备控制状态&quot;)&#10;        reportControlStatus(&#10;            ventilation = finalVentilation,&#10;            disinfection = finalDisinfection,&#10;            heating = finalHeating,&#10;            targetTemperature = finalTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 解析命令响应&#10;     */&#10;    private fun parseCommandResponse(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析命令响应: $payload&quot;)&#10;            addDebugMessage(&quot;解析命令响应: $payload&quot;)&#10;&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 提取请求ID和响应结果&#10;            val requestId = json.get(&quot;id&quot;)?.asString&#10;            val resultCode = json.get(&quot;result_code&quot;)?.asInt ?: -1&#10;            val responseMsg = json.get(&quot;response_detail&quot;)?.asString&#10;&#10;            Log.d(TAG, &quot;命令响应 - requestId: $requestId, resultCode: $resultCode, response: $responseMsg&quot;)&#10;&#10;            requestId?.let { id -&gt;&#10;                commandCallbacks[id]?.let { callback -&gt;&#10;                    commandCallbacks.remove(id)&#10;&#10;                    when (resultCode) {&#10;                        0 -&gt; {&#10;                            // 命令执行成功&#10;                            val successMsg = &quot;设备控制成功&quot;&#10;                            Log.d(TAG, &quot;✅ $successMsg&quot;)&#10;                            addDebugMessage(&quot;✅ $successMsg&quot;)&#10;                            callback(true, successMsg)&#10;                            showToast(successMsg)&#10;                        }&#10;                        else -&gt; {&#10;                            // 命令执行失败&#10;                            val errorMsg = responseMsg ?: &quot;设备控制失败，错误码: $resultCode&quot;&#10;                            Log.w(TAG, &quot;❌ $errorMsg&quot;)&#10;                            addDebugMessage(&quot;❌ $errorMsg&quot;)&#10;                            callback(false, errorMsg)&#10;                            showToast(errorMsg)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 如果没有找到对应的回调，说明可能是其他类型的响应&#10;            if (requestId == null || !commandCallbacks.containsKey(requestId)) {&#10;                Log.d(TAG, &quot;收到未注册的命令响应或其他类型响应&quot;)&#10;                addDebugMessage(&quot;收到未注册的命令响应: $payload&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ 解析命令响应失败&quot;, e)&#10;            addDebugMessage(&quot;❌ 解析命令响应失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 检查设备状态冲突&#10;     * 避免三个开关同时开启可能造成的问题&#10;     */&#10;    private fun checkDeviceStateConflict(&#10;        ventilation: Boolean?,&#10;        disinfection: Boolean?,&#10;        heating: Boolean?&#10;    ): Boolean {&#10;        // 统计要开启的功能数量&#10;        var enabledCount = 0&#10;        if (ventilation == true) enabledCount++&#10;        if (disinfection == true) enabledCount++&#10;        if (heating == true) enabledCount++&#10;&#10;        // 如果同时开启超过2个功能，视为冲突&#10;        if (enabledCount &gt; 2) {&#10;            Log.w(TAG, &quot;⚠️ 状态冲突：不建议同时开启超过2个功能&quot;)&#10;            addDebugMessage(&quot;⚠️ 状态冲突：同时开启功能过多&quot;)&#10;            return true&#10;        }&#10;&#10;        // 特殊冲突检查：通风和加热同时开启可能影响效果&#10;        if (ventilation == true &amp;&amp; heating == true) {&#10;            Log.w(TAG, &quot;⚠�� 状态冲突：通��和加热同时开启可能影响加热效果&quot;)&#10;            addDebugMessage(&quot;⚠️ 状态冲突：通风和加热功能冲突&quot;)&#10;            return true&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * 显示Toast提示&#10;     */&#10;    private fun showToast(message: String) {&#10;        appContext?.let { context -&gt;&#10;            serviceScope.launch(Dispatchers.Main) {&#10;                Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送设备控制消息到华为云IoTDA平台&#10;     */&#10;    fun sendDeviceControlMessage(&#10;        ventilation: Int,&#10;        disinfection: Int,&#10;        heating: Int,&#10;        targetTemperature: Float&#10;    ) {&#10;        val config = currentConfig ?: return&#10;        if (!isConnected || mqttClient?.isConnected != true) {&#10;            Log.w(TAG, &quot;MQTT未连接，无法发送控制消息&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val topic = &quot;\$oc/devices/688879e2d582f20018403921_text1/sys/properties/report&quot;&#10;&#10;            // 构建符合华为云IoTDA标准的消息格式&#10;            val properties = JsonObject().apply {&#10;                addProperty(&quot;ventilation&quot;, ventilation)&#10;                addProperty(&quot;disinfection&quot;, disinfection)&#10;                addProperty(&quot;heating&quot;, heating)&#10;                        addProperty(&quot;target_temperature&quot;, targetTemperature)&#10;            }&#10;&#10;            val service = JsonObject().apply {&#10;                addProperty(&quot;service_id&quot;, &quot;dataText&quot;)&#10;                add(&quot;properties&quot;, properties)&#10;            }&#10;&#10;            val services = com.google.gson.JsonArray().apply {&#10;                add(service)&#10;            }&#10;&#10;            val controlMessage = JsonObject().apply {&#10;                add(&quot;services&quot;, services)&#10;            }&#10;&#10;            val mqttMessage = MqttMessage(controlMessage.toString().toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;            Log.d(TAG, &quot;发送设备控制消息: ${controlMessage.toString()}&quot;)&#10;            addDebugMessage(&quot;发送控制消息: ${controlMessage.toString()}&quot;)&#10;            _lastSentCommand.value = controlMessage.toString()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送设备控制消息失败&quot;, e)&#10;            addDebugMessage(&quot;发送控制消息失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 开始监听设备状态变化并发送控制消息&#10;     */&#10;    private fun startDeviceStateMonitoring() {&#10;        serviceScope.launch {&#10;            var lastVentilation: Boolean? = null&#10;            var lastDisinfection: Boolean? = null&#10;            var lastHeating: Boolean? = null&#10;            var lastTargetTemperature: Float? = null&#10;&#10;            deviceDataManager.deviceData.collect { deviceData -&gt;&#10;                var shouldSendMessage = false&#10;                &#10;                // 检查通风状态是否改变&#10;                if (lastVentilation != null &amp;&amp; lastVentilation != deviceData.ventilationStatus) {&#10;                    shouldSendMessage = true&#10;                }&#10;                &#10;                // 检查消毒状态是否改变&#10;                if (lastDisinfection != null &amp;&amp; lastDisinfection != deviceData.disinfectionStatus) {&#10;                    shouldSendMessage = true&#10;                }&#10;                &#10;                // 检查加热状态是否改变&#10;                if (lastHeating != null &amp;&amp; lastHeating != deviceData.heatingStatus) {&#10;                    shouldSendMessage = true&#10;                }&#10;                &#10;                // 检查目标温度是否改变&#10;                if (lastTargetTemperature != null &amp;&amp; lastTargetTemperature != deviceData.targetTemperature) {&#10;                    shouldSendMessage = true&#10;                }&#10;&#10;                // 如果有状态改变，发送控制消息&#10;                if (shouldSendMessage) {&#10;                    sendDeviceControlMessage(&#10;                        ventilation = if (deviceData.ventilationStatus) 1 else 0,&#10;                        disinfection = if (deviceData.disinfectionStatus) 1 else 0,&#10;                        heating = if (deviceData.heatingStatus) 1 else 0,&#10;                        targetTemperature = deviceData.targetTemperature&#10;                    )&#10;                }&#10;&#10;                // 更新最后状态&#10;                lastVentilation = deviceData.ventilationStatus&#10;                lastDisinfection = deviceData.disinfectionStatus&#10;                lastHeating = deviceData.heatingStatus&#10;                lastTargetTemperature = deviceData.targetTemperature&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.service&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import android.widget.Toast&#10;import com.example.petnestiq.data.DeviceData&#10;import com.example.petnestiq.data.DeviceDataManager&#10;import com.google.gson.Gson&#10;import com.google.gson.JsonObject&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import org.eclipse.paho.client.mqttv3.*&#10;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;import java.util.concurrent.atomic.AtomicReference&#10;import javax.crypto.Mac&#10;import javax.crypto.spec.SecretKeySpec&#10;import kotlin.random.Random&#10;&#10;/**&#10; * 华为云IOTDA平台MQTT服务&#10; */&#10;class HuaweiIoTDAMqttService private constructor() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;HuaweiIoTDAMqttService&quot;&#10;&#10;        @Volatile&#10;        private var INSTANCE: HuaweiIoTDAMqttService? = null&#10;&#10;        fun getInstance(): HuaweiIoTDAMqttService {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: HuaweiIoTDAMqttService().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    // MQTT连接配置&#10;    data class MqttConfig(&#10;        val serverUri: String,          // MQTT服务器地址&#10;        val deviceId: String,           // 设备ID&#10;        val deviceSecret: String = &quot;&quot;,  // 设备密钥（如果使用密钥生成密码）&#10;        val clientId: String,           // 客户端ID&#10;        val username: String,           // 用户名&#10;        val password: String,           // 密码&#10;        val port: Int = 8883           // 端口号&#10;    )&#10;&#10;    // MQTT客户端&#10;    private var mqttClient: MqttClient? = null&#10;    private var currentConfig: MqttConfig? = null&#10;    private val deviceDataManager = DeviceDataManager.getInstance()&#10;    private val gson = Gson()&#10;&#10;    // 连接状态&#10;    private var isConnected = false&#10;    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;&#10;    // 调试数据收集&#10;    private val _debugMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val debugMessages: StateFlow&lt;List&lt;String&gt;&gt; = _debugMessages.asStateFlow()&#10;&#10;    private val _lastReceivedData = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastReceivedData: StateFlow&lt;String?&gt; = _lastReceivedData.asStateFlow()&#10;&#10;    private val _lastSentCommand = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastSentCommand: StateFlow&lt;String?&gt; = _lastSentCommand.asStateFlow()&#10;&#10;    // 添加上下文引用用于显示Toast&#10;    private var appContext: Context? = null&#10;&#10;    // 命令响应回调映射&#10;    private val commandCallbacks = mutableMapOf&lt;String, (Boolean, String?) -&gt; Unit&gt;()&#10;&#10;    /**&#10;     * 配置MQTT连接信息&#10;     */&#10;    fun configure(config: MqttConfig) {&#10;        this.currentConfig = config&#10;    }&#10;&#10;    /**&#10;     * 连接到华为云IOTDA平台&#10;     */&#10;    fun connect(context: Context) {&#10;        val config = currentConfig ?: run {&#10;            Log.e(TAG, &quot;MQTT配置未设置&quot;)&#10;            deviceDataManager.updateConnectionStatus(&quot;配置错误&quot;)&#10;            return&#10;        }&#10;&#10;        appContext = context // 保存上下文引用&#10;&#10;        serviceScope.launch {&#10;            try {&#10;                disconnect() // 先断开已有连接&#10;&#10;                Log.i(TAG, &quot;开始连接MQTT服务器: ${config.serverUri}&quot;)&#10;                deviceDataManager.updateConnectionStatus(&quot;连接中...&quot;)&#10;&#10;                // 使用配置中的密码，如果为空则生成密码&#10;                val password = if (config.password.isNotEmpty()) {&#10;                    config.password&#10;                } else {&#10;                    generatePassword(config.deviceSecret)&#10;                }&#10;&#10;                // 创建MQTT客户端&#10;                mqttClient = MqttClient(config.serverUri, config.clientId, MemoryPersistence())&#10;&#10;                // 配置连接选项&#10;                val options = MqttConnectOptions().apply {&#10;                    userName = config.username&#10;                    this.password = password.toCharArray()&#10;                    isCleanSession = true&#10;                    connectionTimeout = 30&#10;                    keepAliveInterval = 60&#10;                    isAutomaticReconnect = true&#10;                }&#10;&#10;                // 设置回调&#10;                mqttClient?.setCallback(createMqttCallback())&#10;&#10;                // 连接&#10;                mqttClient?.connect(options)&#10;&#10;                // 订阅多个topic来接收设备数据&#10;                subscribeToTopics(config.deviceId)&#10;&#10;                isConnected = true&#10;                Log.i(TAG, &quot;MQTT连接成功&quot;)&#10;                deviceDataManager.updateConnectionStatus(&quot;MQTT连接&quot;)&#10;&#10;                // 开始定期获取设备状态&#10;                startDataPolling()&#10;&#10;                // 开始监听设备状态变化并发送控制消息&#10;                startDeviceStateMonitoring()&#10;&#10;                // 移除监控设备状态变化并下发指令的功能，因为不需要上报数据给MQTT平台&#10;                // startCommandMonitoring()&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;MQTT连接失败&quot;, e)&#10;                isConnected = false&#10;                deviceDataManager.updateConnectionStatus(&quot;连接失败&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 订阅所有相关的MQTT Topic&#10;     */&#10;    private fun subscribeToTopics(deviceId: String) {&#10;        try {&#10;            val topics = listOf(&#10;                // 设备影子相关&#10;                &quot;\$oc/devices/$deviceId/sys/shadow/get/response&quot;,&#10;                &quot;\$oc/devices/$deviceId/sys/shadow/update/response&quot;,&#10;&#10;                // 设备属性上报&#10;                &quot;\$oc/devices/$deviceId/sys/properties/report&quot;,&#10;&#10;                // 设备消息上报&#10;                &quot;\$oc/devices/$deviceId/sys/messages/up&quot;,&#10;&#10;                // 设备事件上报&#10;                &quot;\$oc/devices/$deviceId/sys/events/up&quot;,&#10;&#10;                // 命令响应&#10;                &quot;\$oc/devices/$deviceId/sys/commands/response&quot;,&#10;&#10;                // 通用数据上报topic（根据华为云IoTDA的实际配置）&#10;                &quot;devices/$deviceId/data&quot;,&#10;                &quot;data/$deviceId&quot;,&#10;                &quot;$deviceId/data&quot;,&#10;&#10;                // 可能的自定义topic&#10;                &quot;topic/$deviceId/data&quot;,&#10;                &quot;iot/$deviceId/data&quot;&#10;            )&#10;&#10;            topics.forEach { topic -&gt;&#10;                try {&#10;                    mqttClient?.subscribe(topic, 1)&#10;                    Log.i(TAG, &quot;订阅Topic: $topic&quot;)&#10;                    addDebugMessage(&quot;订阅Topic: $topic&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.w(TAG, &quot;订阅Topic失败: $topic&quot;, e)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;批量订阅Topic失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 断开MQTT连接&#10;     */&#10;    fun disconnect() {&#10;        try {&#10;            if (mqttClient?.isConnected == true) {&#10;                mqttClient?.disconnect()&#10;            }&#10;            mqttClient?.close()&#10;            mqttClient = null&#10;            isConnected = false&#10;            Log.i(TAG, &quot;MQTT连接已断开&quot;)&#10;            deviceDataManager.updateConnectionStatus(null)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;断开MQTT连接时出错&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 获取设备影子状态&#10;     */&#10;    fun getDeviceShadow() {&#10;        val config = currentConfig ?: return&#10;        if (!isConnected || mqttClient?.isConnected != true) return&#10;&#10;        try {&#10;            val requestId = generateRequestId()&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/shadow/get/request_id=$requestId&quot;&#10;&#10;            val message = JsonObject().apply {&#10;                addProperty(&quot;object_device_id&quot;, config.deviceId)&#10;                addProperty(&quot;service_id&quot;, &quot;dataText&quot;)&#10;            }&#10;&#10;            val mqttMessage = MqttMessage(message.toString().toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;            Log.d(TAG, &quot;发送设备影子获取请求: $topic&quot;)&#10;            Log.d(TAG, &quot;请求消息内容: ${message.toString()}&quot;)&#10;            addDebugMessage(&quot;发送�������备影子请求: ${message.toString()}&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;获取设备影子失败&quot;, e)&#10;            addDebugMessage(&quot;设备影子请求失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送设备指令&#10;     */&#10;    private fun sendDeviceCommand(commandType: String, commandValue: Any) {&#10;        val config = currentConfig ?: return&#10;        if (!isConnected || mqttClient?.isConnected != true) return&#10;&#10;        try {&#10;            val requestId = generateRequestId()&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/commands/request_id=$requestId&quot;&#10;&#10;            val command = JsonObject().apply {&#10;                addProperty(&quot;object_device_id&quot;, config.deviceId)&#10;                addProperty(&quot;service_id&quot;, &quot;ControlService&quot;)&#10;&#10;                val paras = JsonObject().apply {&#10;                    addProperty(commandType, commandValue.toString())&#10;                }&#10;                add(&quot;paras&quot;, paras)&#10;            }&#10;&#10;            val commandJson = command.toString()&#10;            val mqttMessage = MqttMessage(commandJson.toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;            Log.d(TAG, &quot;发送设备指令: $commandType = $commandValue&quot;)&#10;&#10;            // 记录调试数据&#10;            addDebugMessage(&quot;发送指令: $commandType = $commandValue&quot;)&#10;            _lastSentCommand.value = commandJson&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送设备指令失败&quot;, e)&#10;            addDebugMessage(&quot;发送指令失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 开始数据轮询&#10;     */&#10;    private fun startDataPolling() {&#10;        serviceScope.launch {&#10;            while (isConnected) {&#10;                try {&#10;                    getDeviceShadow()&#10;                    delay(10000) // 每10秒获取一次数据&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;数据轮询出错&quot;, e)&#10;                    delay(5000)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 创建MQTT回调&#10;     */&#10;    private fun createMqttCallback(): MqttCallback {&#10;        return object : MqttCallback {&#10;            override fun connectionLost(cause: Throwable?) {&#10;                Log.w(TAG, &quot;MQTT连接丢失&quot;, cause)&#10;                isConnected = false&#10;                deviceDataManager.updateConnectionStatus(&quot;连接断开&quot;)&#10;            }&#10;&#10;            override fun messageArrived(topic: String?, message: MqttMessage?) {&#10;                try {&#10;                    val payload = message?.payload?.let { String(it) } ?: return&#10;                    Log.d(TAG, &quot;收到消息 topic: $topic, payload: $payload&quot;)&#10;&#10;                    // 记录调试数据&#10;                    addDebugMessage(&quot;收到消息: $topic&quot;)&#10;                    addDebugMessage(&quot;数据内容: $payload&quot;)&#10;                    _lastReceivedData.value = payload&#10;&#10;                    // 根据topic类型解析不同的消息&#10;                    when {&#10;                        topic?.contains(&quot;shadow/get/response&quot;) == true -&gt; {&#10;                            parseDeviceShadowResponse(payload)&#10;                        }&#10;                        topic?.contains(&quot;properties/report&quot;) == true -&gt; {&#10;                            parsePropertyReport(payload)&#10;                        }&#10;                        topic?.contains(&quot;messages/up&quot;) == true -&gt; {&#10;                            parseDeviceMessage(payload)&#10;                        }&#10;                        topic?.contains(&quot;events/up&quot;) == true -&gt; {&#10;                            parseDeviceEvent(payload)&#10;                        }&#10;                        topic?.contains(&quot;commands/response&quot;) == true -&gt; {&#10;                            parseCommandResponse(payload)&#10;                        }&#10;                        topic?.contains(&quot;/data&quot;) == true -&gt; {&#10;                            parseGenericData(payload)&#10;                        }&#10;                        else -&gt; {&#10;                            // 尝试通用解析&#10;                            parseGenericData(payload)&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;处理MQTT消息失败&quot;, e)&#10;                    addDebugMessage(&quot;处理消息失败: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            override fun deliveryComplete(token: IMqttDeliveryToken?) {&#10;                Log.d(TAG, &quot;消息发送完成&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析设备影子响应&#10;     */&#10;    private fun parseDeviceShadowResponse(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析设备影子响应: $payload&quot;)&#10;            addDebugMessage(&quot;解析设备影子数据: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 支持多种JSON格式解析&#10;            var properties: JsonObject? = null&#10;&#10;            // 1. 解析您的平台格式: shadow[0].reported.properties&#10;            json.getAsJsonArray(&quot;shadow&quot;)?.let { shadowArray -&gt;&#10;                if (shadowArray.size() &gt; 0) {&#10;                    val shadowObj = shadowArray.get(0).asJsonObject&#10;                    val reportedObj = shadowObj.getAsJsonObject(&quot;reported&quot;)&#10;                    if (reportedObj != null) {&#10;                        properties = reportedObj.getAsJsonObject(&quot;properties&quot;)&#10;                        if (properties != null) {&#10;                            Log.d(TAG, &quot;使用平台格式解析: shadow[0].reported.properties&quot;)&#10;                            addDebugMessage(&quot;使用平台格式解析数据&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 2. 如果上述格式不存在，尝试华为云标准格式: shadow.reported[0].properties&#10;            if (properties == null) {&#10;                json.getAsJsonObject(&quot;shadow&quot;)?.getAsJsonArray(&quot;reported&quot;)?.let { reportedArray -&gt;&#10;                    if (reportedArray.size() &gt; 0) {&#10;                        val reportedObj = reportedArray.get(0).asJsonObject&#10;                        properties = reportedObj.getAsJsonObject(&quot;properties&quot;)&#10;                        if (properties != null) {&#10;                            Log.d(TAG, &quot;使用华为云标准格式解析: shadow.reported[0].properties&quot;)&#10;                            addDebugMessage(&quot;使用华为云标准格式解析数据&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 3. 如果标准格式不存在，尝试直接从根级别的properties解析&#10;            if (properties == null &amp;&amp; json.has(&quot;properties&quot;)) {&#10;                properties = json.getAsJsonObject(&quot;properties&quot;)&#10;                Log.d(TAG, &quot;使用根级别properties格式解析&quot;)&#10;                addDebugMessage(&quot;使用根级别properties格式解析数据&quot;)&#10;            }&#10;&#10;            // 4. 如果都不存在，尝试直接从根级别解析所有数据&#10;            if (properties == null) {&#10;                properties = json&#10;                Log.d(TAG, &quot;使用根级别直接解析&quot;)&#10;                addDebugMessage(&quot;使用根级别直接解析数据&quot;)&#10;            }&#10;&#10;            if (properties != null &amp;&amp; properties.size() &gt; 0) {&#10;                var hasUpdatedData = false&#10;&#10;                // 解析温度&#10;                properties.get(&quot;temperature&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val temperature = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        temperature?.let {&#10;                            deviceDataManager.updateTemperature(it)&#10;                            Log.d(TAG, &quot;✅ 更新温度: ${it}°C&quot;)&#10;                            addDebugMessage(&quot;✅ 更新温度: ${it}°C&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析温度失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析温度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析湿度&#10;                properties.get(&quot;humidity&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val humidity = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        humidity?.let {&#10;                            deviceDataManager.updateHumidity(it)&#10;                            Log.d(TAG, &quot;✅ 更新湿度: ${it}%&quot;)&#10;                            addDebugMessage(&quot;✅ 更新湿度: ${it}%&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析湿度失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析湿度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析食物量&#10;                properties.get(&quot;food_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val foodAmount = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        foodAmount?.let {&#10;                            deviceDataManager.updateFoodAmount(it)&#10;                            Log.d(TAG, &quot;✅ 更新食物量: ${it}g&quot;)&#10;                            addDebugMessage(&quot;✅ 更新食物量: ${it}g&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析食物量失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析食物量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析水量&#10;                properties.get(&quot;water_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val waterAmount = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asFloat&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; element.asString.toFloat()&#10;                            else -&gt; null&#10;                        }&#10;                        waterAmount?.let {&#10;                            deviceDataManager.updateWaterAmount(it)&#10;                            Log.d(TAG, &quot;✅ 更新水量: ${it}ml&quot;)&#10;                            addDebugMessage(&quot;✅ 更新水量: ${it}ml&quot;)&#10;                            hasUpdatedData = true&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析水量失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析水量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析通风状态&#10;                properties.get(&quot;ventilation_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val ventilation = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateVentilationStatus(ventilation)&#10;                        Log.d(TAG, &quot;✅ 更新通风状态: $ventilation&quot;)&#10;                        addDebugMessage(&quot;✅ 更新通风状态: $ventilation&quot;)&#10;                        hasUpdatedData = true&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析通风状态失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析通风状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析消毒状态&#10;                properties.get(&quot;disinfection_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val disinfection = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateDisinfectionStatus(disinfection)&#10;                        Log.d(TAG, &quot;✅ 更新消毒状态: $disinfection&quot;)&#10;                        addDebugMessage(&quot;✅ 更新消毒状态: $disinfection&quot;)&#10;                        hasUpdatedData = true&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析消毒状态失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析消毒状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析加热状态&#10;                properties.get(&quot;heating_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val heating = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateHeatingStatus(heating)&#10;                        Log.d(TAG, &quot;✅ 更新加热状态: $heating&quot;)&#10;                        addDebugMessage(&quot;✅ 更新加热状态: $heating&quot;)&#10;                        hasUpdatedData = true&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析加热状态失败: ${element.asString}&quot;)&#10;                        addDebugMessage(&quot;❌ 解析加热状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                if (hasUpdatedData) {&#10;                    Log.d(TAG, &quot; 设备数据更新成功&quot;)&#10;                    addDebugMessage(&quot; 设备数据更新成功&quot;)&#10;                } else {&#10;                    Log.w(TAG, &quot;⚠️ 未能解析出任何有效数据&quot;)&#10;                    addDebugMessage(&quot;⚠️ 未能解析出有效数据&quot;)&#10;&#10;                    // 输出所有可用的字段名以便调试&#10;                    val availableKeys = properties.keySet().toList()&#10;                    Log.d(TAG, &quot;可用字段: $availableKeys&quot;)&#10;                    addDebugMessage(&quot;可用字段: $availableKeys&quot;)&#10;                }&#10;            } else {&#10;                Log.w(TAG, &quot;❌ 未找到有效的属性数据&quot;)&#10;                addDebugMessage(&quot;❌ 未找到有效的属性数据&quot;)&#10;&#10;                // 输出整个JSON结构以便调试&#10;                Log.d(TAG, &quot;完整JSON结构: ${json.toString()}&quot;)&#10;                addDebugMessage(&quot;完整JSON: ${json.toString()}&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ 解析设备影子响应失败&quot;, e)&#10;            addDebugMessage(&quot;❌ 解析失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析属性报告&#10;     */&#10;    private fun parsePropertyReport(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析属性报告: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val properties = json&#10;&#10;            if (properties != null) {&#10;                // 解析温度&#10;                properties.get(&quot;temperature&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val temperature = element.asFloat&#10;                        deviceDataManager.updateTemperature(temperature)&#10;                        Log.d(TAG, &quot;更新温度: $temperature°C&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析温度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析湿度&#10;                properties.get(&quot;humidity&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val humidity = element.asFloat&#10;                        deviceDataManager.updateHumidity(humidity)&#10;                        Log.d(TAG, &quot;更新湿度: $humidity%&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析湿度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析食物量&#10;                properties.get(&quot;food_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val foodAmount = element.asFloat&#10;                        deviceDataManager.updateFoodAmount(foodAmount)&#10;                        Log.d(TAG, &quot;更新食物量: ${foodAmount}g&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析食物量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析水量&#10;                properties.get(&quot;water_amount&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val waterAmount = element.asFloat&#10;                        deviceDataManager.updateWaterAmount(waterAmount)&#10;                        Log.d(TAG, &quot;更新水量: ${waterAmount}ml&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析水量失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析通风状态&#10;                properties.get(&quot;ventilation_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val ventilation = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateVentilationStatus(ventilation)&#10;                        Log.d(TAG, &quot;更新通风状态: $ventilation&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;��析通风状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析消毒状态&#10;                properties.get(&quot;disinfection_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val disinfection = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateDisinfectionStatus(disinfection)&#10;                        Log.d(TAG, &quot;更新消毒状态: $disinfection&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析消毒状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析加热状态&#10;                properties.get(&quot;heating_status&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val heating = when {&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isBoolean -&gt; element.asBoolean&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isNumber -&gt; element.asInt == 1&#10;                            element.isJsonPrimitive &amp;&amp; element.asJsonPrimitive.isString -&gt; {&#10;                                val str = element.asString.lowercase()&#10;                                str == &quot;true&quot; || str == &quot;1&quot; || str == &quot;on&quot;&#10;                            }&#10;                            else -&gt; false&#10;                        }&#10;                        deviceDataManager.updateHeatingStatus(heating)&#10;                        Log.d(TAG, &quot;更新加热状态: $heating&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析加热状态失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                // 解析目标温度&#10;                properties.get(&quot;target_temperature&quot;)?.let { element -&gt;&#10;                    try {&#10;                        val targetTemp = element.asFloat&#10;                        deviceDataManager.updateTargetTemperature(targetTemp)&#10;                        Log.d(TAG, &quot;更新目标温度: $targetTemp°C&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;解析目标温度失败: ${element.asString}&quot;)&#10;                    }&#10;                }&#10;&#10;                Log.d(TAG, &quot;设备状态更新成功&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的属性数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析属性报告失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析设备消息&#10;     */&#10;    private fun parseDeviceMessage(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析设备消息: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val messageData = json&#10;&#10;            if (messageData != null) {&#10;                // TODO: 根据实际消息内容解析并处理&#10;&#10;                Log.d(TAG, &quot;设备消息解析成功: $messageData&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的消息数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析设备消息失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析设备事件&#10;     */&#10;    private fun parseDeviceEvent(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析设备事件: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val eventData = json&#10;&#10;            if (eventData != null) {&#10;                // TODO: 根据实际事件内容解析并处理&#10;&#10;                Log.d(TAG, &quot;设备事件解析成功: $eventData&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的事件数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析设备事件失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 解析通用数据&#10;     */&#10;    private fun parseGenericData(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析通用数据: $payload&quot;)&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 直接从根级别解析数据&#10;            val data = json&#10;&#10;            if (data != null) {&#10;                // TODO: 根据实际数据内容解析并处理&#10;&#10;                Log.d(TAG, &quot;通用数据解析成功: $data&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;未找到有效的数据&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;解析通用数据失败&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成HMAC-SHA256密码&#10;     */&#10;    private fun generatePassword(deviceSecret: String): String {&#10;        try {&#10;            val timestamp = SimpleDateFormat(&quot;yyyyMMddHH&quot;, Locale.getDefault()).format(Date())&#10;            val mac = Mac.getInstance(&quot;HmacSHA256&quot;)&#10;            val secretKeySpec = SecretKeySpec(timestamp.toByteArray(), &quot;HmacSHA256&quot;)&#10;            mac.init(secretKeySpec)&#10;            val result = mac.doFinal(deviceSecret.toByteArray())&#10;            return result.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;生成密码失败&quot;, e)&#10;            return deviceSecret&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 生成请求ID&#10;     */&#10;    private fun generateRequestId(): String {&#10;        return &quot;req_${System.currentTimeMillis()}_${Random.nextInt(1000, 9999)}&quot;&#10;    }&#10;&#10;    /**&#10;     * 获取连接状态&#10;     */&#10;    fun isConnected(): Boolean = isConnected&#10;&#10;    /**&#10;     * 添加调试消息&#10;     */&#10;    private fun addDebugMessage(message: String) {&#10;        val timestamp = SimpleDateFormat(&quot;HH:mm:ss&quot;, Locale.getDefault()).format(Date())&#10;        val debugMessage = &quot;[$timestamp] $message&quot;&#10;&#10;        val currentMessages = _debugMessages.value.toMutableList()&#10;        currentMessages.add(0, debugMessage) // 添加到列表开头&#10;&#10;        // 保持最多50条调试消息&#10;        if (currentMessages.size &gt; 50) {&#10;            currentMessages.removeAt(currentMessages.size - 1)&#10;        }&#10;&#10;        _debugMessages.value = currentMessages&#10;    }&#10;&#10;    /**&#10;     * 清������试消息&#10;     */&#10;    fun clearDebugMessages() {&#10;        _debugMessages.value = emptyList()&#10;    }&#10;&#10;    /**&#10;     * 获取MQTT配置信息&#10;     */&#10;    fun getMqttConfig(): MqttConfig? = currentConfig&#10;&#10;    /**&#10;     * 清理资源&#10;     */&#10;    fun cleanup() {&#10;        serviceScope.cancel()&#10;        disconnect()&#10;    }&#10;&#10;    /**&#10;     * 下发设备消息 - 根据华为云IoTDA平台标准&#10;     * 参考文档: https://support.huaweicloud.com/api-iothub/iot_06_v5_0059.html&#10;     */&#10;    fun sendDeviceMessage(&#10;        ventilation: Int? = null,&#10;        disinfection: Int? = null,&#10;        heating: Int? = null,&#10;        targetTemperature: Int? = null,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        val config = currentConfig ?: run {&#10;            val errorMsg = &quot;MQTT配置未设置&quot;&#10;            Log.e(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        if (!isConnected || mqttClient?.isConnected != true) {&#10;            val errorMsg = &quot;MQTT未连接，无法发送消息&quot;&#10;            Log.w(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        // 检查参数有效性 - 至少要有一个控制参数&#10;        if (ventilation == null &amp;&amp; disinfection == null &amp;&amp; heating == null &amp;&amp; targetTemperature == null) {&#10;            val errorMsg = &quot;至少需要设置一个控制参数&quot;&#10;            Log.w(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            return&#10;        }&#10;&#10;        // 检查状态冲突&#10;        val hasConflict = checkDeviceStateConflict(&#10;            ventilation == 1,&#10;            disinfection == 1,&#10;            heating == 1&#10;        )&#10;        if (hasConflict) {&#10;            val errorMsg = &quot;设备状态冲突，无法执行操作&quot;&#10;            Log.w(TAG, &quot;⚠️ $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val requestId = generateRequestId()&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/commands/request_id=$requestId&quot;&#10;&#10;            // 构建控制指令 - 只包含控制参数，不包含状态数据&#10;            val paras = JsonObject()&#10;&#10;            // 只添加需要控制的参数&#10;            ventilation?.let { paras.addProperty(&quot;ventilation&quot;, it) }&#10;            disinfection?.let { paras.addProperty(&quot;disinfection&quot;, it) }&#10;            heating?.let { paras.addProperty(&quot;heating&quot;, it) }&#10;            targetTemperature?.let { paras.addProperty(&quot;target_temperature&quot;, it) }&#10;&#10;            val command = JsonObject().apply {&#10;                addProperty(&quot;object_device_id&quot;, config.deviceId)&#10;                addProperty(&quot;service_id&quot;, &quot;ControlService&quot;)&#10;                add(&quot;paras&quot;, paras)&#10;            }&#10;&#10;            val commandJson = command.toString()&#10;            val mqttMessage = MqttMessage(commandJson.toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            // 注册回调&#10;            onResult?.let { callback -&gt;&#10;                commandCallbacks[requestId] = callback&#10;&#10;                // 设置超时处理&#10;                serviceScope.launch {&#10;                    delay(10000) // 10秒超时&#10;                    if (commandCallbacks.containsKey(requestId)) {&#10;                        commandCallbacks.remove(requestId)&#10;                        val timeoutMsg = &quot;指���发送超时&quot;&#10;                        callback(false, timeoutMsg)&#10;                        showToast(timeoutMsg)&#10;                    }&#10;                }&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;&#10;            // 记录日志&#10;            val commandParams = mutableListOf&lt;String&gt;()&#10;            ventilation?.let { commandParams.add(&quot;通风开关=${if (it == 1) &quot;开&quot; else &quot;关&quot;}&quot;) }&#10;            disinfection?.let { commandParams.add(&quot;消毒开关=${if (it == 1) &quot;开&quot; else &quot;关&quot;}&quot;) }&#10;            heating?.let { commandParams.add(&quot;加热开关=${if (it == 1) &quot;开&quot; else &quot;关&quot;}&quot;) }&#10;            targetTemperature?.let { commandParams.add(&quot;设定温度=${it}°C&quot;) }&#10;&#10;            val commandDescription = commandParams.joinToString(&quot;, &quot;)&#10;            Log.d(TAG, &quot;✅ 发送控制指令: $commandDescription&quot;)&#10;            addDebugMessage(&quot;✅ 发送控制指令: $commandDescription&quot;)&#10;            addDebugMessage(&quot; 指令内容: $commandJson&quot;)&#10;&#10;            _lastSentCommand.value = commandJson&#10;&#10;        } catch (e: Exception) {&#10;            val errorMsg = &quot;发送控制指令失败: ${e.message}&quot;&#10;            Log.e(TAG, &quot;❌ $errorMsg&quot;, e)&#10;            addDebugMessage(&quot;❌ $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送通风控制指令&#10;     */&#10;    fun sendVentilationCommand(enabled: Boolean, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;ventilation&quot;, if (enabled) 1 else 0)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送通风控制指令: $enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送通风控制指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送消毒控制指令&#10;     */&#10;    fun sendDisinfectionCommand(enabled: Boolean, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;disinfection&quot;, if (enabled) 1 else 0)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送消毒控制指令: $enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送消毒控制指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送加热控制指令&#10;     */&#10;    fun sendHeatingCommand(enabled: Boolean, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;heating&quot;, if (enabled) 1 else 0)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送加热控制指令: $enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送加热控制指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送目标温度设置指令&#10;     */&#10;    fun sendTargetTemperatureCommand(temperature: Int, callback: (Boolean, String?) -&gt; Unit) {&#10;        try {&#10;            sendDeviceCommand(&quot;target_temperature&quot;, temperature)&#10;            callback(true, null)&#10;            Log.d(TAG, &quot;发送目标温度设置指令: $temperature&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送目标温度设置指令失败&quot;, e)&#10;            callback(false, e.message)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 批量控制设备状态 - 带结果回调&#10;     */&#10;    fun controlDeviceState(&#10;        ventilation: Boolean? = null,&#10;        disinfection: Boolean? = null,&#10;        heating: Boolean? = null,&#10;        targetTemperature: Int? = null,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        // 转换为数值参数&#10;        val ventilationValue = ventilation?.let { if (it) 1 else 0 }&#10;        val disinfectionValue = disinfection?.let { if (it) 1 else 0 }&#10;        val heatingValue = heating?.let { if (it) 1 else 0 }&#10;&#10;        Log.d(TAG, &quot;批量控制设备状态&quot;)&#10;        sendDeviceMessage(&#10;            ventilation = ventilationValue,&#10;            disinfection = disinfectionValue,&#10;            heating = heatingValue,&#10;            targetTemperature = targetTemperature,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报设备控制状态到MQTT服务器&#10;     * Topic: $oc/devices/{device_id}/sys/messages/up&#10;     */&#10;    fun reportControlStatus(&#10;        ventilation: Boolean,&#10;        disinfection: Boolean,&#10;        heating: Boolean,&#10;        targetTemperature: Int,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        val config = currentConfig ?: run {&#10;            val errorMsg = &quot;MQTT配置未设置&quot;&#10;            Log.e(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        if (!isConnected || mqttClient?.isConnected != true) {&#10;            val errorMsg = &quot;MQTT未连��，无法上报数据&quot;&#10;            Log.w(TAG, errorMsg)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val topic = &quot;\$oc/devices/${config.deviceId}/sys/messages/up&quot;&#10;&#10;            // 获取当前设备数据以包含完整的状态信息&#10;            val currentData = deviceDataManager.deviceData.value&#10;&#10;            // 构建符合华为云IoTDA标准的消息格式&#10;            val properties = JsonObject().apply {&#10;                // 包含传感器数据&#10;                addProperty(&quot;temperature&quot;, currentData.temperature)&#10;                addProperty(&quot;humidity&quot;, currentData.humidity)&#10;                addProperty(&quot;food_amount&quot;, currentData.foodAmount)&#10;                addProperty(&quot;water_amount&quot;, currentData.waterAmount)&#10;&#10;                // 添加控制状态&#10;                addProperty(&quot;ventilation_status&quot;, ventilation)&#10;                addProperty(&quot;disinfection_status&quot;, disinfection)&#10;                addProperty(&quot;heating_status&quot;, heating)&#10;                addProperty(&quot;target_temperature&quot;, targetTemperature)&#10;            }&#10;&#10;            val service = JsonObject().apply {&#10;                addProperty(&quot;service_id&quot;, &quot;dataText&quot;)&#10;                add(&quot;properties&quot;, properties)&#10;                addProperty(&quot;eventTime&quot;, SimpleDateFormat(&quot;yyyyMMdd'T'HHmmss'Z'&quot;, Locale.getDefault()).format(Date()))&#10;            }&#10;&#10;            val services = com.google.gson.JsonArray().apply {&#10;                add(service)&#10;            }&#10;&#10;            val message = JsonObject().apply {&#10;                add(&quot;services&quot;, services)&#10;            }&#10;&#10;            val messageJson = message.toString()&#10;            val mqttMessage = MqttMessage(messageJson.toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;&#10;            // 记录日志&#10;            val statusDescription = &quot;通风=${if (ventilation) &quot;开&quot; else &quot;关&quot;}, &quot; +&#10;                    &quot;消毒=${if (disinfection) &quot;开&quot; else &quot;关&quot;}, &quot; +&#10;                    &quot;加热=${if (heating) &quot;开&quot; else &quot;关&quot;}, &quot; +&#10;                    &quot;目标温度=${targetTemperature}°C&quot;&#10;&#10;            Log.d(TAG, &quot;✅ 上报控制状态: $statusDescription&quot;)&#10;            addDebugMessage(&quot;✅ 上报控制状态: $statusDescription&quot;)&#10;            addDebugMessage(&quot; 上报数据: $messageJson&quot;)&#10;&#10;            _lastSentCommand.value = messageJson&#10;&#10;            // 立即调用成功回调（因为上报不需要设备响应）&#10;            onResult?.invoke(true, &quot;控制状态上报成功&quot;)&#10;            showToast(&quot;控制状态上报成功&quot;)&#10;&#10;        } catch (e: Exception) {&#10;            val errorMsg = &quot;上报控制状态失败: ${e.message}&quot;&#10;            Log.e(TAG, &quot;❌ $errorMsg&quot;, e)&#10;            addDebugMessage(&quot;�� $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 上报通风开关状态&#10;     */&#10;    fun reportVentilationStatus(enabled: Boolean, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报通风开关状态: ${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentDisinfection = currentData.disinfectionStatus ?: false&#10;        val currentHeating = currentData.heatingStatus ?: false&#10;        val currentTargetTemp = currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        reportControlStatus(&#10;            ventilation = enabled,&#10;            disinfection = currentDisinfection,&#10;            heating = currentHeating,&#10;            targetTemperature = currentTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报消毒开关状态&#10;     */&#10;    fun reportDisinfectionStatus(enabled: Boolean, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报消毒开关状态: ${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentVentilation = currentData.ventilationStatus ?: false&#10;        val currentHeating = currentData.heatingStatus ?: false&#10;        val currentTargetTemp = currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        reportControlStatus(&#10;            ventilation = currentVentilation,&#10;            disinfection = enabled,&#10;            heating = currentHeating,&#10;            targetTemperature = currentTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报加热开关状态&#10;     */&#10;    fun reportHeatingStatus(enabled: Boolean, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报加热开关状态: ${if (enabled) &quot;开启&quot; else &quot;关闭&quot;}&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentVentilation = currentData.ventilationStatus ?: false&#10;        val currentDisinfection = currentData.disinfectionStatus ?: false&#10;        val currentTargetTemp = currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        reportControlStatus(&#10;            ventilation = currentVentilation,&#10;            disinfection = currentDisinfection,&#10;            heating = enabled,&#10;            targetTemperature = currentTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 上报目标温度设置&#10;     */&#10;    fun reportTargetTemperature(temperature: Int, onResult: ((Boolean, String?) -&gt; Unit)? = null) {&#10;        Log.d(TAG, &quot;上报目标温度设置: ${temperature}°C&quot;)&#10;&#10;        // 获取当前其他控制状态&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val currentVentilation = currentData.ventilationStatus ?: false&#10;        val currentDisinfection = currentData.disinfectionStatus ?: false&#10;        val currentHeating = currentData.heatingStatus ?: false&#10;&#10;        reportControlStatus(&#10;            ventilation = currentVentilation,&#10;            disinfection = currentDisinfection,&#10;            heating = currentHeating,&#10;            targetTemperature = temperature,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 批量上报设备控制状态（带状态冲突检查）&#10;     */&#10;    fun reportDeviceControlState(&#10;        ventilation: Boolean? = null,&#10;        disinfection: Boolean? = null,&#10;        heating: Boolean? = null,&#10;        targetTemperature: Int? = null,&#10;        onResult: ((Boolean, String?) -&gt; Unit)? = null&#10;    ) {&#10;        // 获取当前状态作为默认值&#10;        val currentData = deviceDataManager.deviceData.value&#10;        val finalVentilation = ventilation ?: currentData.ventilationStatus ?: false&#10;        val finalDisinfection = disinfection ?: currentData.disinfectionStatus ?: false&#10;        val finalHeating = heating ?: currentData.heatingStatus ?: false&#10;        val finalTargetTemp = targetTemperature ?: currentData.targetTemperature?.toInt() ?: 25&#10;&#10;        // 检查状态冲突&#10;        val hasConflict = checkDeviceStateConflict(finalVentilation, finalDisinfection, finalHeating)&#10;        if (hasConflict) {&#10;            val errorMsg = &quot;设备状态冲突，无法上报&quot;&#10;            Log.w(TAG, &quot;⚠️ $errorMsg&quot;)&#10;            onResult?.invoke(false, errorMsg)&#10;            showToast(errorMsg)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;批量上报设备控制状态&quot;)&#10;        reportControlStatus(&#10;            ventilation = finalVentilation,&#10;            disinfection = finalDisinfection,&#10;            heating = finalHeating,&#10;            targetTemperature = finalTargetTemp,&#10;            onResult = onResult&#10;        )&#10;    }&#10;&#10;    /**&#10;     * 解析命令响应&#10;     */&#10;    private fun parseCommandResponse(payload: String) {&#10;        try {&#10;            Log.d(TAG, &quot;开始解析命令响应: $payload&quot;)&#10;            addDebugMessage(&quot;解析命令响应: $payload&quot;)&#10;&#10;            val json = gson.fromJson(payload, JsonObject::class.java)&#10;&#10;            // 提取请求ID和响应结果&#10;            val requestId = json.get(&quot;id&quot;)?.asString&#10;            val resultCode = json.get(&quot;result_code&quot;)?.asInt ?: -1&#10;            val responseMsg = json.get(&quot;response_detail&quot;)?.asString&#10;&#10;            Log.d(TAG, &quot;命令响应 - requestId: $requestId, resultCode: $resultCode, response: $responseMsg&quot;)&#10;&#10;            requestId?.let { id -&gt;&#10;                commandCallbacks[id]?.let { callback -&gt;&#10;                    commandCallbacks.remove(id)&#10;&#10;                    when (resultCode) {&#10;                        0 -&gt; {&#10;                            // 命令执行成功&#10;                            val successMsg = &quot;设备控制成功&quot;&#10;                            Log.d(TAG, &quot;✅ $successMsg&quot;)&#10;                            addDebugMessage(&quot;✅ $successMsg&quot;)&#10;                            callback(true, successMsg)&#10;                            showToast(successMsg)&#10;                        }&#10;                        else -&gt; {&#10;                            // 命令执行失败&#10;                            val errorMsg = responseMsg ?: &quot;设备控制失败，错误码: $resultCode&quot;&#10;                            Log.w(TAG, &quot;❌ $errorMsg&quot;)&#10;                            addDebugMessage(&quot;❌ $errorMsg&quot;)&#10;                            callback(false, errorMsg)&#10;                            showToast(errorMsg)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // 如果没有找到对应的回调，说明可能是其他类型的响应&#10;            if (requestId == null || !commandCallbacks.containsKey(requestId)) {&#10;                Log.d(TAG, &quot;收到未注册的命令响应或其他类型响应&quot;)&#10;                addDebugMessage(&quot;收到未注册的命令响应: $payload&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ 解析命令响应失败&quot;, e)&#10;            addDebugMessage(&quot;❌ 解析命令响应失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 检查设备状态冲突&#10;     * 避免三个开关同时开启可能造成的问题&#10;     */&#10;    private fun checkDeviceStateConflict(&#10;        ventilation: Boolean?,&#10;        disinfection: Boolean?,&#10;        heating: Boolean?&#10;    ): Boolean {&#10;        // 统计要开启的功能数量&#10;        var enabledCount = 0&#10;        if (ventilation == true) enabledCount++&#10;        if (disinfection == true) enabledCount++&#10;        if (heating == true) enabledCount++&#10;&#10;        // 如果同时开启超过2个功能，视为冲突&#10;        if (enabledCount &gt; 2) {&#10;            Log.w(TAG, &quot;⚠️ 状态冲突：不建议同时开启超过2个功能&quot;)&#10;            addDebugMessage(&quot;⚠️ 状态冲突：同时开启功能过多&quot;)&#10;            return true&#10;        }&#10;&#10;        // 特殊冲突检查：通风和加热同时开启可能影响效果&#10;        if (ventilation == true &amp;&amp; heating == true) {&#10;            Log.w(TAG, &quot;⚠�� 状态冲突：通��和加热同时开启可能影响加热效果&quot;)&#10;            addDebugMessage(&quot;⚠️ 状态冲突：通风和加热功能冲突&quot;)&#10;            return true&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * 显示Toast提示&#10;     */&#10;    private fun showToast(message: String) {&#10;        appContext?.let { context -&gt;&#10;            serviceScope.launch(Dispatchers.Main) {&#10;                Toast.makeText(context, message, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送设备控制消息到华为云IoTDA平台&#10;     */&#10;    fun sendDeviceControlMessage(&#10;        ventilation: Int,&#10;        disinfection: Int,&#10;        heating: Int,&#10;        targetTemperature: Float&#10;    ) {&#10;        val config = currentConfig ?: return&#10;        if (!isConnected || mqttClient?.isConnected != true) {&#10;            Log.w(TAG, &quot;MQTT未连接，无法发送控制消息&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            val topic = &quot;\$oc/devices/688879e2d582f20018403921_text1/sys/properties/report&quot;&#10;&#10;            // 构建符合华为云IoTDA标准的消息格式&#10;            val properties = JsonObject().apply {&#10;                addProperty(&quot;ventilation&quot;, ventilation)&#10;                addProperty(&quot;disinfection&quot;, disinfection)&#10;                addProperty(&quot;heating&quot;, heating)&#10;                        addProperty(&quot;target_temperature&quot;, targetTemperature)&#10;            }&#10;&#10;            val service = JsonObject().apply {&#10;                addProperty(&quot;service_id&quot;, &quot;dataText&quot;)&#10;                add(&quot;properties&quot;, properties)&#10;            }&#10;&#10;            val services = com.google.gson.JsonArray().apply {&#10;                add(service)&#10;            }&#10;&#10;            val controlMessage = JsonObject().apply {&#10;                add(&quot;services&quot;, services)&#10;            }&#10;&#10;            val mqttMessage = MqttMessage(controlMessage.toString().toByteArray()).apply {&#10;                qos = 1&#10;            }&#10;&#10;            mqttClient?.publish(topic, mqttMessage)&#10;            Log.d(TAG, &quot;发送设备控制消息: ${controlMessage.toString()}&quot;)&#10;            addDebugMessage(&quot;发送控制消息: ${controlMessage.toString()}&quot;)&#10;            _lastSentCommand.value = controlMessage.toString()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;发送设备控制消息失败&quot;, e)&#10;            addDebugMessage(&quot;发送控制消息失败: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 开始监听设备状态变化并发送控制消息&#10;     */&#10;    private fun startDeviceStateMonitoring() {&#10;        serviceScope.launch {&#10;            var lastVentilation: Boolean? = null&#10;            var lastDisinfection: Boolean? = null&#10;            var lastHeating: Boolean? = null&#10;            var lastTargetTemperature: Float? = null&#10;&#10;            deviceDataManager.deviceData.collect { deviceData -&gt;&#10;                var shouldSendMessage = false&#10;                &#10;                // 检查通风状态是否改变&#10;                if (lastVentilation != null &amp;&amp; lastVentilation != deviceData.ventilationStatus) {&#10;                    shouldSendMessage = true&#10;                }&#10;                &#10;                // 检查消毒状态是否改变&#10;                if (lastDisinfection != null &amp;&amp; lastDisinfection != deviceData.disinfectionStatus) {&#10;                    shouldSendMessage = true&#10;                }&#10;                &#10;                // 检查加热状态是否改变&#10;                if (lastHeating != null &amp;&amp; lastHeating != deviceData.heatingStatus) {&#10;                    shouldSendMessage = true&#10;                }&#10;                &#10;                // 检查目标温度是否改变&#10;                if (lastTargetTemperature != null &amp;&amp; lastTargetTemperature != deviceData.targetTemperature) {&#10;                    shouldSendMessage = true&#10;                }&#10;&#10;                // 如果有状态改变，发送控制消息&#10;                if (shouldSendMessage) {&#10;                    sendDeviceControlMessage(&#10;                        ventilation = if (deviceData.ventilationStatus) 1 else 0,&#10;                        disinfection = if (deviceData.disinfectionStatus) 1 else 0,&#10;                        heating = if (deviceData.heatingStatus) 1 else 0,&#10;                        targetTemperature = deviceData.targetTemperature&#10;                    )&#10;                }&#10;&#10;                // 更新最后状态&#10;                lastVentilation = deviceData.ventilationStatus&#10;                lastDisinfection = deviceData.disinfectionStatus&#10;                lastHeating = deviceData.heatingStatus&#10;                lastTargetTemperature = deviceData.targetTemperature&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * 发送语音数据到MQTT服务器&#10;     * @param audioData 音频数据的字节数组&#10;     * @param deviceId 目标设备ID&#10;     */&#10;    fun sendVoiceData(audioData: ByteArray, deviceId: String = &quot;default_device&quot;) {&#10;        serviceScope.launch {&#10;            try {&#10;                if (!isConnected()) {&#10;                    Log.w(TAG, &quot;MQTT未连接，无法发送语音数据&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // 构建语音消息&#10;                val voiceMessage = JsonObject().apply {&#10;                    addProperty(&quot;msgType&quot;, &quot;voice&quot;)&#10;                    addProperty(&quot;deviceId&quot;, deviceId)&#10;                    addProperty(&quot;timestamp&quot;, System.currentTimeMillis())&#10;                    addProperty(&quot;audioFormat&quot;, &quot;PCM&quot;)&#10;                    addProperty(&quot;sampleRate&quot;, 16000)&#10;                    addProperty(&quot;channels&quot;, 1)&#10;                    addProperty(&quot;bitDepth&quot;, 16)&#10;                    // 将音频数据编码为Base64&#10;                    addProperty(&quot;audioData&quot;, android.util.Base64.encodeToString(audioData, android.util.Base64.DEFAULT))&#10;                }&#10;&#10;                val topic = &quot;voice/upload/$deviceId&quot;&#10;                val message = MqttMessage(voiceMessage.toString().toByteArray())&#10;                message.qos = 1 // 确保消息可靠传输&#10;&#10;                mqttClient?.publish(topic, message)&#10;                Log.d(TAG, &quot;语音数据发送成功，大小: ${audioData.size} bytes&quot;)&#10;                addDebugMessage(&quot;✅ 语音数据发送成功，大小: ${audioData.size} bytes&quot;)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;发送语音数据失败&quot;, e)&#10;                addDebugMessage(&quot;❌ 发送语音数据失败: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>