<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/ChatData.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/ChatData.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import java.util.UUID&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * 聊天消息数据类&#10; */&#10;data class ChatMessage(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val content: String,&#10;    val isFromUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val isTyping: Boolean = false&#10;) {&#10;    fun getFormattedTime(): String {&#10;        val sdf = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;        return sdf.format(Date(timestamp))&#10;    }&#10;}&#10;&#10;/**&#10; * DeepSeek API 请求数据模型&#10; */&#10;data class DeepSeekRequest(&#10;    val model: String = &quot;deepseek-chat&quot;,&#10;    val messages: List&lt;ApiMessage&gt;,&#10;    val temperature: Double = 0.7,&#10;    val max_tokens: Int = 1000,&#10;    val stream: Boolean = false&#10;)&#10;&#10;data class ApiMessage(&#10;    val role: String, // &quot;user&quot; 或 &quot;assistant&quot; 或 &quot;system&quot;&#10;    val content: String&#10;)&#10;&#10;/**&#10; * DeepSeek API 响应数据模型&#10; */&#10;data class DeepSeekResponse(&#10;    val id: String,&#10;    val objectType: String,&#10;    val created: Long,&#10;    val model: String,&#10;    val choices: List&lt;Choice&gt;,&#10;    val usage: Usage&#10;)&#10;&#10;data class Choice(&#10;    val index: Int,&#10;    val message: ApiMessage,&#10;    val finish_reason: String&#10;)&#10;&#10;data class Usage(&#10;    val prompt_tokens: Int,&#10;    val completion_tokens: Int,&#10;    val total_tokens: Int&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#10;&#10;import java.util.UUID&#10;import java.text.SimpleDateFormat&#10;import java.util.Date&#10;import java.util.Locale&#10;&#10;/**&#10; * 聊天消息数据类&#10; */&#10;data class ChatMessage(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val content: String,&#10;    val isFromUser: Boolean,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val isTyping: Boolean = false,&#10;    val isStreaming: Boolean = false&#10;) {&#10;    fun getFormattedTime(): String {&#10;        val sdf = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault())&#10;        return sdf.format(Date(timestamp))&#10;    }&#10;}&#10;&#10;/**&#10; * DeepSeek API 请求数据模型&#10; */&#10;data class DeepSeekRequest(&#10;    val model: String = &quot;deepseek-chat&quot;,&#10;    val messages: List&lt;ApiMessage&gt;,&#10;    val temperature: Double = 0.7,&#10;    val max_tokens: Int = 1000,&#10;    val stream: Boolean = false&#10;)&#10;&#10;data class ApiMessage(&#10;    val role: String, // &quot;user&quot; 或 &quot;assistant&quot; 或 &quot;system&quot;&#10;    val content: String&#10;)&#10;&#10;/**&#10; * DeepSeek API 响应数据模型&#10; */&#10;data class DeepSeekResponse(&#10;    val id: String,&#10;    val objectType: String,&#10;    val created: Long,&#10;    val model: String,&#10;    val choices: List&lt;Choice&gt;,&#10;    val usage: Usage&#10;)&#10;&#10;data class Choice(&#10;    val index: Int,&#10;    val message: ApiMessage,&#10;    val finish_reason: String&#10;)&#10;&#10;data class Usage(&#10;    val prompt_tokens: Int,&#10;    val completion_tokens: Int,&#10;    val total_tokens: Int&#10;)&#10;&#10;/**&#10; * 流式响应数据模型&#10; */&#10;data class StreamChoice(&#10;    val index: Int,&#10;    val delta: StreamDelta,&#10;    val finish_reason: String?&#10;)&#10;&#10;data class StreamDelta(&#10;    val content: String?&#10;)&#10;&#10;data class StreamResponse(&#10;    val id: String,&#10;    val objectType: String,&#10;    val created: Long,&#10;    val model: String,&#10;    val choices: List&lt;StreamChoice&gt;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/DeviceConfigManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/DeviceConfigManager.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;data class MqttConfig(&#10;    val serverUrl: String = &quot;mqtt://localhost&quot;,&#10;    val port: Int = 1883,&#10;    val clientId: String = &quot;PetNestIQ_Client&quot;,&#10;    val username: String = &quot;&quot;,&#10;    val password: String = &quot;&quot;,&#10;    val subscribeTopic: String = &quot;/device/data&quot;,&#10;    val publishTopic: String = &quot;/device/control&quot;,&#10;    val useSSL: Boolean = false,&#10;    val autoReconnect: Boolean = true&#10;)&#10;&#10;data class BluetoothConfig(&#10;    val deviceName: String = &quot;PetNest Device&quot;,&#10;    val macAddress: String = &quot;&quot;,&#10;    val autoConnect: Boolean = false,&#10;    val connectionTimeout: Int = 30&#10;)&#10;&#10;data class DeviceConfig(&#10;    val name: String,&#10;    val mqttConfig: MqttConfig,&#10;    val bluetoothConfig: BluetoothConfig,&#10;    val timestamp: Long = System.currentTimeMillis()&#10;)&#10;&#10;class DeviceConfigManager private constructor(private val context: Context) {&#10;    private val preferences: SharedPreferences = context.getSharedPreferences(&#10;        &quot;device_config_prefs&quot;, Context.MODE_PRIVATE&#10;    )&#10;&#10;    private val gson = Gson()&#10;&#10;    // MQTT配置状态&#10;    private val _mqttConfig = MutableStateFlow(loadMqttConfig())&#10;    val mqttConfig: StateFlow&lt;MqttConfig&gt; = _mqttConfig.asStateFlow()&#10;&#10;    // 蓝牙配置状态&#10;    private val _bluetoothConfig = MutableStateFlow(loadBluetoothConfig())&#10;    val bluetoothConfig: StateFlow&lt;BluetoothConfig&gt; = _bluetoothConfig.asStateFlow()&#10;&#10;    // 已保存的配置列表&#10;    private val _configList = MutableStateFlow(loadConfigList())&#10;    val configList: StateFlow&lt;List&lt;String&gt;&gt; = _configList.asStateFlow()&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DeviceConfigManager? = null&#10;&#10;        fun getInstance(context: Context): DeviceConfigManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DeviceConfigManager(context.applicationContext).also { INSTANCE = it }&#10;            }&#10;        }&#10;&#10;        private const val KEY_MQTT_CONFIG = &quot;mqtt_config&quot;&#10;        private const val KEY_BLUETOOTH_CONFIG = &quot;bluetooth_config&quot;&#10;        private const val KEY_CONFIG_LIST = &quot;config_list&quot;&#10;        private const val KEY_CONFIG_PREFIX = &quot;saved_config_&quot;&#10;    }&#10;&#10;    // 加载MQTT配置&#10;    private fun loadMqttConfig(): MqttConfig {&#10;        val configJson = preferences.getString(KEY_MQTT_CONFIG, null)&#10;        return if (configJson != null) {&#10;            try {&#10;                gson.fromJson(configJson, MqttConfig::class.java) ?: MqttConfig()&#10;            } catch (e: Exception) {&#10;                MqttConfig() // 返回默认配置&#10;            }&#10;        } else {&#10;            MqttConfig() // 返回默认配置&#10;        }&#10;    }&#10;&#10;    // 加载蓝牙配置&#10;    private fun loadBluetoothConfig(): BluetoothConfig {&#10;        val configJson = preferences.getString(KEY_BLUETOOTH_CONFIG, null)&#10;        return if (configJson != null) {&#10;            try {&#10;                gson.fromJson(configJson, BluetoothConfig::class.java) ?: BluetoothConfig()&#10;            } catch (e: Exception) {&#10;                BluetoothConfig() // 返回默认配置&#10;            }&#10;        } else {&#10;            BluetoothConfig() // 返回默认配置&#10;        }&#10;    }&#10;&#10;    // 加载配置列表&#10;    private fun loadConfigList(): List&lt;String&gt; {&#10;        val configListJson = preferences.getString(KEY_CONFIG_LIST, null)&#10;        return if (configListJson != null) {&#10;            try {&#10;                val type = object : TypeToken&lt;List&lt;String&gt;&gt;() {}.type&#10;                gson.fromJson(configListJson, type) ?: emptyList()&#10;            } catch (e: Exception) {&#10;                emptyList()&#10;            }&#10;        } else {&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // 更新MQTT配置&#10;    fun updateMqttConfig(config: MqttConfig) {&#10;        _mqttConfig.value = config&#10;        saveMqttConfig(config)&#10;    }&#10;&#10;    // 更新蓝牙配置&#10;    fun updateBluetoothConfig(config: BluetoothConfig) {&#10;        _bluetoothConfig.value = config&#10;        saveBluetoothConfig(config)&#10;    }&#10;&#10;    // 保存MQTT配置&#10;    private fun saveMqttConfig(config: MqttConfig) {&#10;        val configJson = gson.toJson(config)&#10;        preferences.edit()&#10;            .putString(KEY_MQTT_CONFIG, configJson)&#10;            .apply()&#10;    }&#10;&#10;    // 保存蓝牙配置&#10;    private fun saveBluetoothConfig(config: BluetoothConfig) {&#10;        val configJson = gson.toJson(config)&#10;        preferences.edit()&#10;            .putString(KEY_BLUETOOTH_CONFIG, configJson)&#10;            .apply()&#10;    }&#10;&#10;    // 保存完整配置组合&#10;    fun saveConfig(name: String) {&#10;        val deviceConfig = DeviceConfig(&#10;            name = name,&#10;            mqttConfig = _mqttConfig.value,&#10;            bluetoothConfig = _bluetoothConfig.value&#10;        )&#10;&#10;        // 保存配置到SharedPreferences&#10;        val configJson = gson.toJson(deviceConfig)&#10;        preferences.edit()&#10;            .putString(KEY_CONFIG_PREFIX + name, configJson)&#10;            .apply()&#10;&#10;        // 更新配置列表&#10;        val currentList = _configList.value.toMutableList()&#10;        if (!currentList.contains(name)) {&#10;            currentList.add(name)&#10;            _configList.value = currentList&#10;            saveConfigList(currentList)&#10;        }&#10;    }&#10;&#10;    // 加载完整配置组合&#10;    fun loadConfig(name: String) {&#10;        val configJson = preferences.getString(KEY_CONFIG_PREFIX + name, null)&#10;        if (configJson != null) {&#10;            try {&#10;                val deviceConfig = gson.fromJson(configJson, DeviceConfig::class.java)&#10;                if (deviceConfig != null) {&#10;                    updateMqttConfig(deviceConfig.mqttConfig)&#10;                    updateBluetoothConfig(deviceConfig.bluetoothConfig)&#10;                }&#10;            } catch (e: Exception) {&#10;                // 加载失败，保持当前配置&#10;            }&#10;        }&#10;    }&#10;&#10;    // 删除保存的配置&#10;    fun deleteConfig(name: String) {&#10;        preferences.edit()&#10;            .remove(KEY_CONFIG_PREFIX + name)&#10;            .apply()&#10;&#10;        val currentList = _configList.value.toMutableList()&#10;        currentList.remove(name)&#10;        _configList.value = currentList&#10;        saveConfigList(currentList)&#10;    }&#10;&#10;    // 保存配置列表&#10;    private fun saveConfigList(list: List&lt;String&gt;) {&#10;        val listJson = gson.toJson(list)&#10;        preferences.edit()&#10;            .putString(KEY_CONFIG_LIST, listJson)&#10;            .apply()&#10;    }&#10;&#10;    // 获取当前MQTT配置（用于其他组件访问）&#10;    fun getCurrentMqttConfig(): MqttConfig = _mqttConfig.value&#10;&#10;    // 获取当前蓝牙配置（用于其他组件访问）&#10;    fun getCurrentBluetoothConfig(): BluetoothConfig = _bluetoothConfig.value&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.content.SharedPreferences&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import com.google.gson.Gson&#13;&#10;import com.google.gson.reflect.TypeToken&#13;&#10;&#13;&#10;data class MqttConfig(&#13;&#10;    val serverUrl: String = &quot;ssl://e35491cb0c.st1.iotda-device.cn-north-4.myhuaweicloud.com&quot;,&#13;&#10;    val port: Int = 8883,&#13;&#10;    val clientId: String = &quot;688879e2d582f20018403921_text1_0_0_2025072907&quot;,&#13;&#10;    val username: String = &quot;688879e2d582f20018403921_text1&quot;,&#13;&#10;    val password: String = &quot;bdd6a2f87eab3e9dd81325957547fa3b5b566f1abfbdb9850249b3b4984f277e&quot;,&#13;&#10;    val subscribeTopic: String = &quot;/device/data&quot;,&#13;&#10;    val publishTopic: String = &quot;/device/control&quot;,&#13;&#10;    val useSSL: Boolean = true,&#13;&#10;    val autoReconnect: Boolean = true&#13;&#10;)&#13;&#10;&#13;&#10;data class BluetoothConfig(&#13;&#10;    val deviceName: String = &quot;PetNest Device&quot;,&#13;&#10;    val macAddress: String = &quot;&quot;,&#13;&#10;    val autoConnect: Boolean = false,&#13;&#10;    val connectionTimeout: Int = 30&#13;&#10;)&#13;&#10;&#13;&#10;data class DeviceConfig(&#13;&#10;    val name: String,&#13;&#10;    val mqttConfig: MqttConfig,&#13;&#10;    val bluetoothConfig: BluetoothConfig,&#13;&#10;    val timestamp: Long = System.currentTimeMillis()&#13;&#10;)&#13;&#10;&#13;&#10;class DeviceConfigManager private constructor(private val context: Context) {&#13;&#10;    private val preferences: SharedPreferences = context.getSharedPreferences(&#13;&#10;        &quot;device_config_prefs&quot;, Context.MODE_PRIVATE&#13;&#10;    )&#13;&#10;&#13;&#10;    private val gson = Gson()&#13;&#10;&#13;&#10;    // MQTT配置状态&#13;&#10;    private val _mqttConfig = MutableStateFlow(loadMqttConfig())&#13;&#10;    val mqttConfig: StateFlow&lt;MqttConfig&gt; = _mqttConfig.asStateFlow()&#13;&#10;&#13;&#10;    // 蓝牙配置状态&#13;&#10;    private val _bluetoothConfig = MutableStateFlow(loadBluetoothConfig())&#13;&#10;    val bluetoothConfig: StateFlow&lt;BluetoothConfig&gt; = _bluetoothConfig.asStateFlow()&#13;&#10;&#13;&#10;    // 已保存的配置列表&#13;&#10;    private val _configList = MutableStateFlow(loadConfigList())&#13;&#10;    val configList: StateFlow&lt;List&lt;String&gt;&gt; = _configList.asStateFlow()&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        @Volatile&#13;&#10;        private var INSTANCE: DeviceConfigManager? = null&#13;&#10;&#13;&#10;        fun getInstance(context: Context): DeviceConfigManager {&#13;&#10;            return INSTANCE ?: synchronized(this) {&#13;&#10;                INSTANCE ?: DeviceConfigManager(context.applicationContext).also { INSTANCE = it }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private const val KEY_MQTT_CONFIG = &quot;mqtt_config&quot;&#13;&#10;        private const val KEY_BLUETOOTH_CONFIG = &quot;bluetooth_config&quot;&#13;&#10;        private const val KEY_CONFIG_LIST = &quot;config_list&quot;&#13;&#10;        private const val KEY_CONFIG_PREFIX = &quot;saved_config_&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载MQTT配置&#13;&#10;    private fun loadMqttConfig(): MqttConfig {&#13;&#10;        val configJson = preferences.getString(KEY_MQTT_CONFIG, null)&#13;&#10;        return if (configJson != null) {&#13;&#10;            try {&#13;&#10;                gson.fromJson(configJson, MqttConfig::class.java) ?: MqttConfig()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                MqttConfig() // 返回默认配置&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            MqttConfig() // 返回默认配置&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载蓝牙配置&#13;&#10;    private fun loadBluetoothConfig(): BluetoothConfig {&#13;&#10;        val configJson = preferences.getString(KEY_BLUETOOTH_CONFIG, null)&#13;&#10;        return if (configJson != null) {&#13;&#10;            try {&#13;&#10;                gson.fromJson(configJson, BluetoothConfig::class.java) ?: BluetoothConfig()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                BluetoothConfig() // 返回默认配置&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            BluetoothConfig() // 返回默认配置&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载配置列表&#13;&#10;    private fun loadConfigList(): List&lt;String&gt; {&#13;&#10;        val configListJson = preferences.getString(KEY_CONFIG_LIST, null)&#13;&#10;        return if (configListJson != null) {&#13;&#10;            try {&#13;&#10;                val type = object : TypeToken&lt;List&lt;String&gt;&gt;() {}.type&#13;&#10;                gson.fromJson(configListJson, type) ?: emptyList()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                emptyList()&#13;&#10;            }&#13;&#10;        } else {&#13;&#10;            emptyList()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 更新MQTT配置&#13;&#10;    fun updateMqttConfig(config: MqttConfig) {&#13;&#10;        _mqttConfig.value = config&#13;&#10;        saveMqttConfig(config)&#13;&#10;    }&#13;&#10;&#13;&#10;    // 更新蓝牙配置&#13;&#10;    fun updateBluetoothConfig(config: BluetoothConfig) {&#13;&#10;        _bluetoothConfig.value = config&#13;&#10;        saveBluetoothConfig(config)&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存MQTT配置&#13;&#10;    private fun saveMqttConfig(config: MqttConfig) {&#13;&#10;        val configJson = gson.toJson(config)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_MQTT_CONFIG, configJson)&#13;&#10;            .apply()&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存蓝牙配置&#13;&#10;    private fun saveBluetoothConfig(config: BluetoothConfig) {&#13;&#10;        val configJson = gson.toJson(config)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_BLUETOOTH_CONFIG, configJson)&#13;&#10;            .apply()&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存完整配置组合&#13;&#10;    fun saveConfig(name: String) {&#13;&#10;        val deviceConfig = DeviceConfig(&#13;&#10;            name = name,&#13;&#10;            mqttConfig = _mqttConfig.value,&#13;&#10;            bluetoothConfig = _bluetoothConfig.value&#13;&#10;        )&#13;&#10;&#13;&#10;        // 保存配置到SharedPreferences&#13;&#10;        val configJson = gson.toJson(deviceConfig)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_CONFIG_PREFIX + name, configJson)&#13;&#10;            .apply()&#13;&#10;&#13;&#10;        // 更新配置列表&#13;&#10;        val currentList = _configList.value.toMutableList()&#13;&#10;        if (!currentList.contains(name)) {&#13;&#10;            currentList.add(name)&#13;&#10;            _configList.value = currentList&#13;&#10;            saveConfigList(currentList)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 加载完整配置组合&#13;&#10;    fun loadConfig(name: String) {&#13;&#10;        val configJson = preferences.getString(KEY_CONFIG_PREFIX + name, null)&#13;&#10;        if (configJson != null) {&#13;&#10;            try {&#13;&#10;                val deviceConfig = gson.fromJson(configJson, DeviceConfig::class.java)&#13;&#10;                if (deviceConfig != null) {&#13;&#10;                    updateMqttConfig(deviceConfig.mqttConfig)&#13;&#10;                    updateBluetoothConfig(deviceConfig.bluetoothConfig)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // 加载失败，保持当前配置&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // 删除保存的配置&#13;&#10;    fun deleteConfig(name: String) {&#13;&#10;        preferences.edit()&#13;&#10;            .remove(KEY_CONFIG_PREFIX + name)&#13;&#10;            .apply()&#13;&#10;&#13;&#10;        val currentList = _configList.value.toMutableList()&#13;&#10;        currentList.remove(name)&#13;&#10;        _configList.value = currentList&#13;&#10;        saveConfigList(currentList)&#13;&#10;    }&#13;&#10;&#13;&#10;    // 保存配置列表&#13;&#10;    private fun saveConfigList(list: List&lt;String&gt;) {&#13;&#10;        val listJson = gson.toJson(list)&#13;&#10;        preferences.edit()&#13;&#10;            .putString(KEY_CONFIG_LIST, listJson)&#13;&#10;            .apply()&#13;&#10;    }&#13;&#10;&#13;&#10;    // 获取当前MQTT配置（用于其他组件访问）&#13;&#10;    fun getCurrentMqttConfig(): MqttConfig = _mqttConfig.value&#13;&#10;&#13;&#10;    // 获取当前蓝牙配置（用于其他组件访问）&#13;&#10;    fun getCurrentBluetoothConfig(): BluetoothConfig = _bluetoothConfig.value&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/UserInfoManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/petnestiq/data/UserInfoManager.kt" />
              <option name="originalContent" value="package com.example.petnestiq.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.State&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;&#10;// 用户信息数据类&#10;data class UserInfo(&#10;    val nickname: String,&#10;    val petBreed: String,&#10;    val petAge: String,&#10;    val avatarResourceId: Int = com.example.petnestiq.R.drawable.cat,&#10;    val avatarUri: String? = null,&#10;    val savedAvatarPath: String? = null&#10;)&#10;&#10;// 用户信息管理器&#10;class UserInfoManager private constructor(private val context: Context) {&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: UserInfoManager? = null&#10;&#10;        private const val PREFS_NAME = &quot;user_info_prefs&quot;&#10;        private const val KEY_NICKNAME = &quot;nickname&quot;&#10;        private const val KEY_PET_BREED = &quot;pet_breed&quot;&#10;        private const val KEY_PET_AGE = &quot;pet_age&quot;&#10;        private const val KEY_AVATAR_RESOURCE_ID = &quot;avatar_resource_id&quot;&#10;        private const val KEY_AVATAR_URI = &quot;avatar_uri&quot;&#10;        private const val KEY_SAVED_AVATAR_PATH = &quot;saved_avatar_path&quot;&#10;        private const val AVATAR_FILENAME = &quot;user_avatar.jpg&quot;&#10;&#10;        fun getInstance(context: Context): UserInfoManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: UserInfoManager(context.applicationContext).also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    // 使用StateFlow管理用户信息状态&#10;    private val _userInfo = MutableStateFlow(loadUserInfo())&#10;    val userInfo: StateFlow&lt;UserInfo&gt; = _userInfo.asStateFlow()&#10;&#10;    // 从SharedPreferences加载用户信息&#10;    private fun loadUserInfo(): UserInfo {&#10;        val savedPath = prefs.getString(KEY_SAVED_AVATAR_PATH, null)&#10;        val validSavedPath = if (savedPath != null &amp;&amp; File(savedPath).exists()) {&#10;            savedPath&#10;        } else {&#10;            null&#10;        }&#10;&#10;        return UserInfo(&#10;            nickname = prefs.getString(KEY_NICKNAME, &quot;铲屎官&quot;) ?: &quot;铲屎官&quot;,&#10;            petBreed = prefs.getString(KEY_PET_BREED, &quot;英短&quot;) ?: &quot;英短&quot;,&#10;            petAge = prefs.getString(KEY_PET_AGE, &quot;2岁&quot;) ?: &quot;2岁&quot;,&#10;            avatarResourceId = prefs.getInt(KEY_AVATAR_RESOURCE_ID, com.example.petnestiq.R.drawable.cat),&#10;            avatarUri = prefs.getString(KEY_AVATAR_URI, null),&#10;            savedAvatarPath = validSavedPath&#10;        )&#10;    }&#10;&#10;    // 保存用户信息到SharedPreferences&#10;    private fun saveUserInfo(userInfo: UserInfo) {&#10;        prefs.edit().apply {&#10;            putString(KEY_NICKNAME, userInfo.nickname)&#10;            putString(KEY_PET_BREED, userInfo.petBreed)&#10;            putString(KEY_PET_AGE, userInfo.petAge)&#10;            putInt(KEY_AVATAR_RESOURCE_ID, userInfo.avatarResourceId)&#10;            putString(KEY_AVATAR_URI, userInfo.avatarUri)&#10;            putString(KEY_SAVED_AVATAR_PATH, userInfo.savedAvatarPath)&#10;            apply()&#10;        }&#10;    }&#10;&#10;    // 保存头像应用内部存储&#10;    private fun saveAvatarToInternalStorage(uri: Uri): String? {&#10;        return try {&#10;            val inputStream = context.contentResolver.openInputStream(uri)&#10;            val bitmap = BitmapFactory.decodeStream(inputStream)&#10;            inputStream?.close()&#10;                compressedBitmap.recycle()&#10;&#10;                avatarFile.absolutePath&#10;            } else {&#10;                null&#10;            }&#10;        } catch (e: IOException) {&#10;            e.printStackTrace()&#10;            null&#10;        }&#10;    }&#10;&#10;    // 压缩图片&#10;    private fun compressBitmap(bitmap: Bitmap, maxWidth: Int, maxHeight: Int): Bitmap {&#10;        val width = bitmap.width&#10;        val height = bitmap.height&#10;&#10;        val ratio = minOf(maxWidth.toFloat() / width, maxHeight.toFloat() / height)&#10;&#10;        return if (ratio &lt; 1) {&#10;            val newWidth = (width * ratio).toInt()&#10;            val newHeight = (height * ratio).toInt()&#10;            Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)&#10;        } else {&#10;            bitmap&#10;        }&#10;    }&#10;&#10;    // 更新用户信息&#10;    fun updateUserInfo(newUserInfo: UserInfo) {&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;    }&#10;&#10;    // 更新昵称&#10;    fun updateNickname(nickname: String) {&#10;        val newUserInfo = _userInfo.value.copy(nickname = nickname)&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;    }&#10;&#10;    // 更新宠物品种&#10;    fun updatePetBreed(breed: String) {&#10;        val newUserInfo = _userInfo.value.copy(petBreed = breed)&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;    }&#10;&#10;    // 更新宠物年龄&#10;    fun updatePetAge(age: String) {&#10;        val newUserInfo = _userInfo.value.copy(petAge = age)&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;    }&#10;&#10;    // 更新头像（资源ID）&#10;    fun updateAvatar(resourceId: Int) {&#10;        val newUserInfo = _userInfo.value.copy(&#10;            avatarResourceId = resourceId,&#10;            avatarUri = null, // 清除URI&#10;            savedAvatarPath = null // 清除保存的路径&#10;        )&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;&#10;        // 删除旧的头像文件&#10;        deleteOldAvatarFile()&#10;    }&#10;&#10;    // 更新头像（URI）- 同时保存到内部存储&#10;    fun updateAvatarUri(uri: String) {&#10;        try {&#10;            val uriObj = Uri.parse(uri)&#10;            val savedPath = saveAvatarToInternalStorage(uriObj)&#10;&#10;            val newUserInfo = _userInfo.value.copy(&#10;                avatarUri = uri,&#10;                savedAvatarPath = savedPath&#10;            )&#10;            _userInfo.value = newUserInfo&#10;            saveUserInfo(newUserInfo)&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            val newUserInfo = _userInfo.value.copy(avatarUri = uri)&#10;            _userInfo.value = newUserInfo&#10;            saveUserInfo(newUserInfo)&#10;        }&#10;    }&#10;&#10;    // 删除旧的头像文件&#10;    private fun deleteOldAvatarFile() {&#10;        try {&#10;            val avatarFile = File(context.filesDir, AVATAR_FILENAME)&#10;            if (avatarFile.exists()) {&#10;                avatarFile.delete()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    // 获取宠物信息格式化字符串&#10;    fun getPetInfoDisplay(): String {&#10;        val info = _userInfo.value&#10;        return &quot;${info.petBreed} | ${info.petAge}&quot;&#10;    }&#10;&#10;    // 判断是否使用自定义头像&#10;    fun isUsingCustomAvatar(): Boolean {&#10;        return _userInfo.value.savedAvatarPath != null || _userInfo.value.avatarUri != null&#10;    }&#10;&#10;    // 获取头像显示路径（优先使用保存的路径）&#10;    fun getAvatarDisplayPath(): String? {&#10;        val userInfo = _userInfo.value&#10;        return userInfo.savedAvatarPath ?: userInfo.avatarUri&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.petnestiq.data&#10;&#10;import android.content.Context&#10;import androidx.compose.animation.core.tween&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.net.Uri&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.State&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;    val isTyping: Boolean = false&#10;    val nickname: String,&#10;    val petBreed: String,&#10;    val petAge: String,&#10;    val avatarResourceId: Int = com.example.petnestiq.R.drawable.cat,&#10;    val avatarUri: String? = null,&#10;    val savedAvatarPath: String? = null&#10;)&#10;&#10;// 用户信息管理器&#10;class UserInfoManager private constructor(private val context: Context) {&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: UserInfoManager? = null&#10;&#10;        private const val PREFS_NAME = &quot;user_info_prefs&quot;&#10;        private const val KEY_NICKNAME = &quot;nickname&quot;&#10;        private const val KEY_PET_BREED = &quot;pet_breed&quot;&#10;        private const val KEY_PET_AGE = &quot;pet_age&quot;&#10;        private const val KEY_AVATAR_RESOURCE_ID = &quot;avatar_resource_id&quot;&#10;        private const val KEY_AVATAR_URI = &quot;avatar_uri&quot;&#10;                slideInHorizontally(&#10;                    initialOffsetX = { 300 },&#10;                    animationSpec = tween(300)&#10;                ) + fadeIn(animationSpec = tween(300))&#10;        prefs.edit().apply {&#10;            putString(KEY_NICKNAME, userInfo.nickname)&#10;                slideOutHorizontally(&#10;                    targetOffsetX = { -300 },&#10;                    animationSpec = tween(300)&#10;                ) + fadeOut(animationSpec = tween(300))&#10;&#10;    // 更新昵称&#10;    fun updateNickname(nickname: String) {&#10;        val newUserInfo = _userInfo.value.copy(nickname = nickname)&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;    }&#10;&#10;    // 更新宠物品种&#10;    fun updatePetBreed(breed: String) {&#10;        val newUserInfo = _userInfo.value.copy(petBreed = breed)&#10;        _userInfo.value = newUserInfo&#10;        saveUserInfo(newUserInfo)&#10;        deleteOldAvatarFile()&#10;    }&#10;&#10;    // 更新头像（URI）- 同时保存到内部存储&#10;    fun updateAvatarUri(uri: String) {&#10;        try {&#10;            val uriObj = Uri.parse(uri)&#10;            val savedPath = saveAvatarToInternalStorage(uriObj)&#10;&#10;                compressedBitmap.recycle()&#10;            if (avatarFile.exists()) {&#10;                avatarFile.delete()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;    }&#10;&#10;    // 获取宠物信息格式化字符串&#10;    fun getPetInfoDisplay(): String {&#10;        val info = _userInfo.value&#10;        return &quot;${info.petBreed} | ${info.petAge}&quot;&#10;    }&#10;&#10;    // 判断是否使用自定义头像&#10;    fun isUsingCustomAvatar(): Boolean {&#10;        return _userInfo.value.savedAvatarPath != null || _userInfo.value.avatarUri != null&#10;    }&#10;&#10;    // 获取头像显示路径（优先使用保存的路径）&#10;    fun getAvatarDisplayPath(): String? {&#10;        val userInfo = _userInfo.value&#10;        return userInfo.savedAvatarPath ?: userInfo.avatarUri&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>